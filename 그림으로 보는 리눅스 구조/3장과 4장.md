- 어려웠다.
    - 맨 처름 가상 메모리가 어떻게 메모리 단편화를 해결해주고 있는지 이해되지 않았다.
    - `MELTDOWN` 취약점
- 새롭게 알았다.
    - 프로세스에 메모리를 할당하기 위해서 커널의 메모리 관리 시스템이 있다는 사실
    - 멀티프로세스로 동작할 때 서로 같은 주소를 사용하기 때문에 충돌을 방지하기 위해 가상 주소 공간을 사용한다는 점이 흥미롭게 다가왔다.
    - 또한 이 가상메모리와 실제 메모리 주소를 매핑하고 있는 페이징 테이블도 메모리 공간을 많이 차지하기 때문에 이 메모리 공간을 절약하기 위해
        - 메모리 영역 할당과 실제 확보한 메모리를 물리 메모리에 할당하는 작업이 나눠진다는 점
        - 페이지 테이블의 계층과
            - Huge Page
            - Transparent Huge Page
        
        부분들이 흥미롭게 다가왔다.
        
    - 실제로 회사에서 로그 파일이 너무 커져서 실제 운영되고 있는 모니터링 서버가 꺼지는 상황이 발생했었다. 그 때 OOM이 발생했었는데 단순히 그 상황이 메모리가 부족하다는 상황이라고 인식했었지만 이 책을 읽고 나서 재활용 가능한 메모리(버퍼나 캐시)를 확보하고 나서도 메모리 공간이 부족하자 적당한 프로세스를 골라 종료시켰다는 사실을 알게 되었다. 그리고 이를 OOM 킬러라고 칭하며 `dmesg`를 통해서 커널로그를 확인할 수 있음을 알게 되었다.
    - 페이지 폴트의 개념도 새롭게 알게 되었다. 페이지 테이블에 가상 메모리 중에서 물리 메모리가 연결되어 있지 않은데 해당 주소를 접근하려고 하면 cpu가 중간에서 별도의 처리로 예외를 던지는 것이다.
- 더 알아봤다.
    
    ### OOM killer 회피
    
    ```
    $ echo -17 > /proc/<pid>/oom_adj
    ```
    
    `OOM killer`를 끌 수는 없지만 `OOM killer`의 `OOM scoring` 대상에서 벗어나는 것은 가능하다.
    
    - `-17`에서 `15`까지의 범위를 가지며, 값이 낮을수록 프로세스가 종료될 가능성이 낮습니다.
    - `17`은 가장 낮은 조정 값으로, 이 값을 설정하면 해당 프로세스는 OOM 상황에서 종료될 가능성이 매우 낮습니다.
    - 반대로, 높은 값 (예: `15`)은 해당 프로세스가 OOM 상황에서 종료될 가능성이 높다는 것을 의미합니다.
