# croup
>시스템 메모리나 CPU 같은 자원을 어떤 프로세스에 얼마나 제공할 것인지 세밀하게 제어하는 기능
>프로세스를 그룹으로 나눠서 각종 자원을 제어하는 개념에서 cgroup이라는 명칭이 붙었다.

이 절에서는 
- cgroup이 왜 필요한지
- 구체적으로 어떤 자원을 어떻게 제어하는지 배운다.

시스템을 안정적으로 운용하기 위해서는 특정 프로세스 또는 사용자가 자원을 독점하지 못하게 제어하고 싶을 때가 있다.
"여러 사용자가 공유하는 렌탈 사업자, IaaS 같은 클라우드 서비스 제공자" 입장에서 매우 중요한 기능이다.

아래의 경우를 생각해볼 수 있다.
- 만약에 IaaS로부터 컨테이너나 가상 머신을 빌렸는데 이를 다른 사용자가 시스템 자원을 지나치게 많이 사용하는 바람에 요금이 많이 나온다면 우리가 피해를 보게 된다. 따라서 이 문제를 필하기 위해서 자원을 제어할 필요성이 있다.
- 백그라운드로 동작 중인 데이터 백업 처리와 일반 업무 처리의 데이터 베이스 접속의 저장소 입출력 대역폭을 지정하고 싶은 경우

## cgroup으로 제정 가능한 자원
> cgroup은 자원마다 컨트롤러라고 하는 커널 내부 프로그램을 통해 자원을 제어한다.

cgroup 컨트롤러
|컨트롤러명|제어하는 자원|설명|
|:---:|:--:|:--:|
|cpu 컨트롤러|cpu|단위 시간당 cpu 사용 시간 등|
|메모리 컨트롤러|메모리|메모리 사용량이나 OOM Killer 영향 범위 등|
|blkio컨트롤러|블록 입출력|저장소 입출력 대역폭 등|
|네트워크 컨트롤러|네트워크 입출력|네트워크 입출력 대역폭 등|


- 각종 자원은 프로세스 그룹 단위로 제어할 수 있다.
- 각 컨트롤러는 **cgroupfs**라고 하는 특별한 파일 시스템을 사용한다.
- 이 파일 시스템은 컨트롤러 별로 고유한 값이 되고 우분투 20.04라면 **/sys/fs/cgroup/** 디렉토리 아래에 컨트롤러에 대응하는 cgroup 파일 시스템이 마운트 된다.
  실제로 아래와 같이 출력되었다.
  ![image](https://github.com/user-attachments/assets/ab2ea973-e083-4ac5-9148-ef3e662e708a)
- 책에서 이 가상 경로에 존재하는 파일들은 실제 저장장치에 존재하는 것이 아니라 메모리에 존재한다고 해서 이게 뭔말인가 싶었다.
  일단 여기서 말하는 마운트라는 것을 나는 이렇게 이해했는데 디바이스마다 디바이스 파일들이 있고 이 디바이스 파일을 통해서 해당 디바이스 즉 하드웨어에 접근한다.
  그런데 마운트라는 것은 디바이스 파일에 접근할 수 있는 가상 경로를 만들고 그 가상경로에 들어가면 저 디바이스 파일이 접근하는 하드웨어 파일들을 볼 수 있게 하는 것 같다.
  다시 정리하면 기존에 저장된 파일들을 운영체제의 특정 디렉토리 경로와 연결하는 작업인 것이다.
  예를 들어, USB에 document.txt 파일이 있다면, USB를 /mnt/usb에 마운트한 후 /mnt/usb/document.txt 경로로 들어가면 이 파일을 볼 수 있.
  하지만 이 파일은 USB 드라이브에 실제로 저장된 것이고, /mnt/usb는 그 파일에 접근할 수 있는 경로일 뿐이다.
  마운트 작업은 운영체제가 외부 저장 장치나 다른 파일 시스템에 접근할 수 있도록 하기 위한 필수적인 과정이다. 이를 통해, 운영체제가 해당 저장 장치에 있는 데이터를 인식하고, 파일을 읽거나 쓸 수 있게 된다.
  따라서 명령어로 아래와 같다.
  ```
  sudo mount /dev/sdb1 /mnt/usb
  ```
  그러나 책에서 말하는 메모리에 존재한다는 것은 무슨 말일까?
  chat gpt에 물어보니 아래와 같이 답변했다.
  ```
  1) 일반적인 파일 시스템 마운트
  일반적인 마운트는, 하드 디스크, SSD, USB 드라이브 같은 물리적 저장 장치에 존재하는 파일 시스템을 특정 경로(마운트 포인트)에 연결하는 것입니다.
  예를 들어, sudo mount /dev/sdb1 /mnt/usb 명령을 사용하면, /dev/sdb1에 저장된 실제 데이터(파일 시스템에 저장된 파일들)를 /mnt/usb라는 경로를 통해 액세스할 수 있습니다.
  이 경우, 파일들이 메모리에만 존재하는 것이 아니라 물리적인 디스크에 저장됩니다. 메모리는 파일 시스템에서 데이터를 캐싱하거나 읽고 쓰기 작업을 빠르게 처리하기 위해 일시적으로 사용될 수 있지만, 파일의 실제 저장 위치는 하드 드라이브와 같은 물리적 장치입니다.
  2) 가상 파일 시스템 (예: /sys, /proc, cgroup 등)
  가상 파일 시스템은 물리적 저장 장치와는 상관없이 메모리에서만 존재하며, 커널의 상태를 파일 형태로 제공하는 경우입니다.
  /sys, /proc, /sys/fs/cgroup 같은 경로에 있는 파일 시스템은 물리적 장치에 존재하는 파일들이 아니라, 커널 내부의 데이터를 메모리에서 바로 보여주고 제어하는 방식입니다.
  예: /proc/meminfo 파일을 열면 시스템 메모리 정보를 볼 수 있지만, 이 파일 자체는 물리적인 디스크에 저장된 데이터가 아닙니다. 메모리에서 커널의 상태를 실시간으로 읽어오는 것이죠.
  ```
  그래서 **서버를 껐다가 키면 메모리의 내용이 사라지기 때문에 내가 설정한 컨트롤러의 값들을 사라진다고 한다.** 근데 직접 해봐야할 거 같다. 실헝해보고 추가하겠다.

## 사용예 : cpu 사용 시간 제어
cpu 컨트롤러를 사용해서 cpu 사용 시간 제어의 종류
- 어떤 그룹이 일정 기간 동안 사용할 수 있는 cpu 시간을 제어한다.
- 어떤 그룹이 사용할 수 있는 cpu 시간 비율을 다른 그룹보다 높게 또는 낮게 제어한다.

책에서의 예시는 첫 번째 방법을 사용한다.
그리고 책에서는 cgroup v1에 대한 예시로 설명했는데 지금 내가 사용하는 ec2 프리티어는 cgroup v2여서 그 방법으로 설명한다.
- /sys/fs/cgroup/cpu/아래에 있는 수많은 파일이 존재하는데, 이 파일은 모든 프로세스가 속하는 기본 그룹에 설정하는 값이다.
- 이 기본 그룹 밑에 다시 디렉토리를 만들면 새로운 그룹을 만들 수 있다.
  ```
  sudo mkdir /sys/fs/cgroup/my_group
  ```
  그리고 나면 해당 파일에 pid를 쓰면 대응하는 프로세스가 my_group에 속하게 된다.
- cpu 대역폭 컨트롤러를 통해서 시간을 제어하는데 먼저 기본적인 설정값으로 프로그램을 실행한다.
  ```
  ./inf-loop.py &
  echo 322274 | sudo tee /sys/fs/cgroup/my_group/cgroup.procs
  ```
  ![image](https://github.com/user-attachments/assets/ae4c866b-86b9-476b-b24f-64150c204a98)
  기본적인 설정으로는 100프로 모두 사용한다. 내가 해당 ec2에서 다른 것들을 돌리고 있어서 90으로 나오기는 한다.
- CPU 사용량을 50%로 제한: 주기를 100,000µs(기본값)으로 설정하고, 그 주기 동안 50,000µs만 사용할 수 있도록 제한한다.
  ```
  echo "50000 100000" | sudo tee /sys/fs/cgroup/my_group/cpu.max
  ```
  ![image](https://github.com/user-attachments/assets/c639cffc-58ae-4c5d-b05d-f55af86cd82a)
  
  
