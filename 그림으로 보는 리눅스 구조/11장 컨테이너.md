# 컨테이너
- 리눅스 컨테이너 기술에 대해서 배운다.
- 컨테이너 기술을 사용한 소프트웨어
  - 도커 :  컨테이너 애플리케이션을 관리
  - 쿠버네티스 : 도커 등을 활용한 컨테이너 오케스트레이션 시스템
- 일반시스템, 가상머신, 컨테이너의 비교
  ![image](https://github.com/user-attachments/assets/f1645a17-c13d-4faa-9992-0a7ff84ae173)

## 가상 머신과 차이점
"모두 독립된 프로세스 실행환경을 제공하는 점은 같다."

- 가상 머신
  - 각 가상 머신의 가상 하드웨어와 커널을 사용
    따라서 가상 머신은 윈도에서 리눅스를 실행하는 등 완전히 다른 호스트 OS를 쓸 수 있다.
  - 실행되는 모습
    1. 호스트 OS의 가상화 소프트웨어가 가상 머신을 기동, 2부터는 가상 머신에서 일어나는 처리
    2. GRUB 같은 부트 로더가 기동한다.
    3. 부트 로더가 커널을 기동한다.
    4. 커널이 init 프로그램을 기동한다.
    5. init 프로세스가 각종 서비스를 시작한다.
- 컨테이너
  - 컨테이너가 동작하는 호스트 OS와 모든 켄티어가 하나의 커널을 공유, 리눅스 컨테이너는 리눅스 커널에서만 동작하는 시스템만을 사용할 수 있다.
  - 실행되는 모습
    1. 컨테이너 런타임 프로세스가 컨테이너를 작성하고 최초 프로세스를 기동한다.
- 정리
  - 기동속도 : 컨테이너는 가상 머신에 필요한 1에서 3번까지 처리가 전부 생략 가능한다.
  - 하드웨어 접근 속도 : 가상 머신을 10장에서 설명한 것처럼 하드웨어 접근에 의해 물리 기기에 제어를 넘겨야 하는 반면에, 컨테이너는 그럴 필요가 없다.
  ![image](https://github.com/user-attachments/assets/1f655e5e-e6d5-469b-b02b-bb1d566a4bae)

## 컨테이너 종류
- 시스템 컨테이너 : 일반 리눅스 환경처럼 다양한 애플리케이션을 실행하기 위한 컨테이너
  - 시스템 컨테이너는 최초 프로스세로 init 프로세스를 실행하고 init이 각종 서비스를 실행해서 다양한 애플리케이션이 동작하는 환경을 만든다. 이후에는 가상 머신과 다를게 없는 느낌으로 사용한다.
- 애플리케이션 컨테이너 : 일반적으로 컨테이너에서 하나의 애플리케이션만 동작하는 컨테이너, 도커가 등장하면서 순식간에 보급되었다.
![image](https://github.com/user-attachments/assets/8ad04826-d5ce-4166-a51b-003f7660e7c2)

## 네임스페이스
커널에는 컨테이너라고 부르는 기능은 없다.
단지 커널의 네임스페이스 기능을 잘 활용해서 구현한 것이다.

>네임스페이스는 **시스템에 있는 다양한 종류의 자원에 사용할 수 있는데, 모두가 이런 자원을 공유하는 것은 아니라 소속된 프로세스에 독립된 자원인 것처럼 만들어주는 기능**이다.

네임스페이스 종류
- 프로세스 ID 네임스페이스 : 독립된 pid 이름 공간을 제공한다.
- 사용자 네임스페이스 : 독립된 uid, gid를 제공한다.
- 마운트 네임스페이스 : 독립된 파일 시스쳄 마운트를 제공한다.

## 프로세스 ID 네임스페이스
- 시스템을 기동하면 모드 프로세스가 소속된 루트 프로세스 ID 네임스페이스가 존재한다.
- 루트 프로세스 ID 네임스페이스 내부 새로운 네임스페이스 생성하기
  - 현재 프로세스가 소속된 프로세스 ID 네임스페이스 확인
    ```
    ls -l /proc/$$/ns/pid
    ```
    ![image](https://github.com/user-attachments/assets/736917dd-3b65-4202-b705-3b98d50c4642)
    이 명령어를 실행한 bash는 4026531836가 ID인 프로세스 ID 네임스페이스 소속이다.
    저 ID는 루트 프로세스 ID 네임스페이스의 ID이다.

  - 새로운 프로세스 ID 네임스페이슬르 작성하고 거기에서 프로그램 실행하기
    ```
    sudo unshare --fork --pid --mount-proc bash
    ```
    - ```sudo```: 이 명령어는 슈퍼유저 권한으로 실행되어야 하므로, sudo를 사용합니다. 네임스페이스와 같은 시스템 수준 리소스를 다루기 위해서는 관리자 권한이 필요합니다.

    - ```unshare```: 리눅스의 네임스페이스를 분리(격리)하는 명령어입니다. 네임스페이스는 프로세스, 파일 시스템, 네트워크 등 시스템 리소스를 다른 프로세스와 분리하여 독립된 환경을 제공하는 메커니즘입니다. unshare는 기존 환경과 격리된 새로운 네임스페이스를 생성하는 데 사용됩니다.

    - ```--fork```: 이 옵션은 새로운 프로세스를 생성하는 데 사용됩니다. 즉, 이 명령어는 새로운 네임스페이스에서 새로운 프로세스를 생성하여 그 안에서 실행을 시작합니다.

    - ```--pid```: 새로운 PID 네임스페이스를 생성합니다. PID 네임스페이스는 프로세스 ID를 격리하여, 네임스페이스 내부의 프로세스들이 서로 다른 네임스페이스에서 실행 중인 다른 프로세스의 PID를 볼 수 없도록 합니다. 네임스페이스 내에서 첫 번째 프로세스는 항상 PID 1을 가지며, 이는 새로운 네임스페이스의 "init" 프로세스 역할을 합니다.

    - ```--mount-proc```: 이 옵션은 새로운 PID 네임스페이스에서 /proc 파일 시스템을 마운트하는 데 사용됩니다. /proc은 시스템 프로세스 정보를 담고 있는 가상 파일 시스템입니다. 새로운 네임스페이스에서 PID 격리가 적용되기 때문에, 해당 네임스페이스 내의 /proc은 해당 네임스페이스의 프로세스 정보만을 보여줍니다.

    - ```bash```: 이 명령은 새로운 네임스페이스 내에서 실행할 프로그램입니다. 여기서는 bash 쉘을 실행하여, 사용자가 새로운 네임스페이스에서 명령어를 실행할 수 있는 환경을 제공합니다.
  - 현재 **셸 프로세스의 PID(프로세스 ID)**를 출력
    ```
    echo $$
    1
    ```
  - 독립된 네임 스페이스에서 프로세스 목록 출력하기
    ```
    ps ax
    ```
    ![image](https://github.com/user-attachments/assets/a8a474dc-7f46-4c79-9fe8-fca6d23be333)
 - 독립된 프로세스 ID의 네임스페이스 ID를 확인하고 이를 루트와 비교해보기
   ```
   ls -l /proc/1/ns/pid
   ```
   ![image](https://github.com/user-attachments/assets/fc778d98-4f8a-401e-a0e4-40ef735d7af4)
   ![image](https://github.com/user-attachments/assets/736917dd-3b65-4202-b705-3b98d50c4642)

   서로 값이 다른 것을 확인할 수 있다.
 - 다른 단말로 들어가서 루트 프로스세 ID 네임스페이스에서 독립된 네임스페이스의 프로세스 목록이 출력되는지 확인해보기
   ```
   pstree -p 
   ```
   ![image](https://github.com/user-attachments/assets/056eaa77-37ed-47e0-adf3-03af4e31eebb)
   unshare의 자식인 bash(id=311371)가 새로운 프로세스 ID의 네임스페이스에서 동작하고 있는 bash이다.

- 호스트 OS에서 이 프로세스가 속한 프로세스 ID의 네임스페이스를 확인
  ```
  sudo ls -l /proc/311371/ns/pid
  ```
  ![image](https://github.com/user-attachments/assets/364adcee-b277-4b57-a2a2-5b70a1eb5392)
  앞서 ``` ls -l /proc/1/ns/pid``` 이 명령어로 통해서 본 id와 일치하는 것을 확인할 수 있다.

여기서 확인할 수 있는 것은 루트 프로세스 ID 네임스페이스에서 보는 pid와 새로운 프로스세 ID 네임스페이스에서 보는 pid가 서로 다르다는 것이다.

이를 포함해 전체적인 부분을 그림으로 나타내면 아래와 같다.
![image](https://github.com/user-attachments/assets/ede62238-08ce-4475-80d8-e449b03d886f)

위 과정을 통해서 하나 더 네임 스페이스를 만들어보면 아래와 같다.
![image](https://github.com/user-attachments/assets/624ee2e2-b213-4c16-89bf-e20a1c504dfe)

## 컨테이너 정체
![image](https://github.com/user-attachments/assets/51206b52-b0ec-4a63-874f-eb2d305d7533)

- 컨테이너 : 독립된 네임스페이스를 가지고 다른 프로세스와 실행 환경이 나뉘는 하나 또는 여러 프로세스
- 호스트 OS나 다른 컨테이너에서 발생한 문제가 있을 때 커널을 공유하기 때문에 컨테이너 내부에서는 그 원인을 알 수 없다.

## 보안 위험성
- 컨테이너는 일반적으로 가상 머신에 비해 보안 위험성이 크다.
- 컨테이너는 호스트 시스템 및 모든 컨테이너가 커널을 공유한다. 따라서 커널에 취약점이 있으면 악의를 품은 컨테이너 사용자로 인해 호스트 OS 또는 다른 컨테이너의 정보가 누출될 수 있다.
- 반면에 가상 머신은 그 영향이 가상머신의 하드웨어 수준에서 끝난다.
- 이런 문제점 때문에 다양한 종류의 컨테이너 런타임이 생겨났다.
- 다양한 컨테이너 런타임
  - Kata Container : 각 컨테이너가 경량 VM에서 동작한다.
  - gVisor : 각 컨테이너가 호출하는 시스템 콜은 시용자 공간에서 구현한 커널에서 처리한다.
  - runC : 도커가 기본적으로 사용하는 컨테이너 런타임
 
## 책 읽으면서 생겼던 의문점
실제로 컨테이너는 커널을 독립적으로 못 만든다고 하였지만 나는 구현하면서 도커에 리눅스를 띄운적이 있었서 책에 말이 이상하다고 생각했다.
그래서 찾아보니 
 윈도우에서 리눅스 컨테이너를 실행할 수 있는 이유는 Docker가 이를 지원하기 위해 **WSL 2(Windows Subsystem for Linux 2)** 등을 활용해서 실행한다고 한다.
