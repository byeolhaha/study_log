# 10장 가상화 기능
## 가상화 기능이란 무엇인가
>PC나 서버 등의 물리적인 기기에서 가상 머신을 동작시키는 소프트웨어 기능 및 그런 동작을 돕는 하드웨어 기능의 조합

아래의 용도의 경우 사용
- 1대의 물리 기기에 여러 시스템 가동 => 각각의 가상 머신을 고객이 빌려쓰는 IaaS
- 수십 대의 물리 기기로 구성된 시스템을 가상 머신으로 대체
- 레거시 시스템 수명 연장 : 하드웨어 지원이 끝난 오래된 시스템을 가상 머신에서 가동
- 어떤 OS에서 다른 OS 사용하기
- 개발, 테스트 환경 
## 가상화 소프트웨어
> 가상 머신의 생성, 삭제 관리 담당
가상화 소프트웨어는 물리 기기의 하드웨어 자원을 관리하고 가상 머신에 나눠준다.

- 물리 CPU : 물리 기기의 cpu => PCPU
- 가상 CPU : 가상 머신의 cpu => VCPU

![image](https://github.com/user-attachments/assets/3698defa-79a7-483e-ab1c-3bfd155e93c0)
가상화 소프트웨어와 가상 머신의 관계는 커널의 프로세스 관리 시스템과 프로스의 관계와 닮았다.

![image](https://github.com/user-attachments/assets/69506fa7-9798-40dd-9da9-a652a51b5026)

가상화 소프트웨어를 구현하는 방법
- 하드웨어에 직접 하이퍼바이저 가상화 소프트웨어를 설치하는 방법
- 기존 OS를 바탕으로 애플리케이션으로 동작하는 방법
- 유명한 소프트웨어
  - VM사의 각종 제품
  - 오라클의 버츄얼박스
  - 마이크로소프트사의 하이퍼V
  - 시트릭스 시스템즈사의 젠

## 이 장에서 사용하는 가상화 소프트웨어
세 종류의 소프트웨어를 조합해서 가상 머신 작성 및 관리
- KVM : 리눅스 커널이 제공하는 가상화 기능
- QEMU : CPU 및 하드웨어 에뮬레이터 , KVM과 같이 사용한다면 하드웨어 에뮬레이터만 사용
- virt - manager : 가상 머신 생성, 관리, 삭제를 지원

이 부분을 공부하면서 구체적으로 저 KVM과 QEMU가 무엇인지 그리고 에뮬레이터에 대한 뜻이 궁금해서 더 찾아보았다.

**에뮬레이션(emulation)**은 한 시스템이 다른 시스템의 동작을 모방하는 것을 의미합니다. 즉, 소프트웨어나 하드웨어가 자신의 원래 환경이 아닌 다른 환경에서 동작할 수 있도록 만드는 과정을 말합니다. 에뮬레이션을 통해 한 시스템에서 다른 시스템의 동작을 완벽하게 흉내 낼 수 있어, 호환되지 않는 하드웨어나 운영체제에서도 소프트웨어를 실행할 수 있습니다.

에뮬레이션의 핵심 요소
다른 아키텍처나 시스템의 동작을 재현: 에뮬레이터는 특정 하드웨어나 소프트웨어 환경을 모방하여, 그 환경에서 실행해야 하는 프로그램이 다른 환경에서도 정상적으로 동작하게 합니다. 예를 들어, x86 아키텍처에서 ARM 아키텍처의 프로그램을 실행할 수 있습니다.

정확한 동작 모방: 에뮬레이터는 모방 대상의 구체적인 동작을 최대한 동일하게 흉내 냅니다. 하드웨어나 소프트웨어가 실제로 어떻게 동작하는지 분석하고 이를 재현합니다.

에뮬레이션의 예시
1. 게임 콘솔 에뮬레이터:
  예를 들어, 오래된 닌텐도(Nintendo) 게임을 최신 컴퓨터에서 실행하고 싶다면, 닌텐도 에뮬레이터를 사용합니다. 이 에뮬레이터는 닌텐도 하드웨어의 동작을 흉내 내어, 게임을 PC에서 실행할 수 있게 합니다.
   여기서 에뮬레이터는 닌텐도의 CPU, 메모리, 그래픽 처리 등을 소프트웨어로 모방합니다.
2. QEMU에서 CPU 에뮬레이션:
  QEMU는 다른 CPU 아키텍처를 에뮬레이트할 수 있습니다. 예를 들어, x86 기반의 컴퓨터에서 ARM 프로세서를 사용하는 모바일 애플리케이션을 테스트할 때, ARM 기반 시스템을 가지고 있지 않더라도 QEMU를 통해 ARM CPU의 동작을 에뮬레이션할 수 있습니다.
   이를 통해 x86 시스템에서 ARM 환경을 실행할 수 있게 되는 것입니다.
3. QEMU의 하드웨어 에뮬레이터 :
   다양한 하드웨어 아키텍처를 소프트웨어로 흉내 내는 기능을 제공합니다. 이를 통해, QEMU는 서로 다른 아키텍처에서 동작하는 운영체제나 소프트웨어를 실행할 수 있도록 도와줍니다. QEMU의 하드웨어 에뮬레이션은 특히 이종 아키텍처 간 호환성을 제공하는 데 중요한 역할

둘의 관계
1. KVM 단독 사용:
  KVM은 가상 머신의 CPU와 메모리를 가상화하여 네이티브 성능에 가까운 속도로 가상 머신을 실행합니다.
  하지만 KVM만으로는 네트워크 장치나 디스크 드라이브 같은 하드웨어 구성에 대한 유연성이 부족합니다.
2. QEMU 단독 사용:
   QEMU는 CPU, 메모리, 디스크, 네트워크 등을 모두 소프트웨어로 에뮬레이션할 수 있습니다. 그러나, CPU 성능이 낮아져 가상 머신이 느리게 실행됩니다.
3. QEMU + KVM 결합:
  QEMU는 디스크, 네트워크, USB 등 다양한 하드웨어 장치를 에뮬레이션하고, KVM은 호스트 CPU의 하드웨어 가속을 사용하여 성능을 크게 향상시킵니다.
  결과적으로, 가상 머신은 빠르게 실행되며, 다양한 하드웨어 장치를 사용할 수 있습니다.

그래서 이들의 관계를 그림으로 그리면 아래와 같다.
![image](https://github.com/user-attachments/assets/9560cdaa-e025-4760-a72d-68bfe0863775)

virt-manaeger와 qemu은 리눅스 커널 입장에서 그저 프로세스에 불과하다
아래와 같은 흐름을 가진다.
1. virt-manager가 새로운 가상 머신 기반 형태를 만든다.
2. virt-manager가 형태를 바탕으로 가상 머신을 생성해서 QEMU를 기동한다.
3. QEMU와 KVM이 연계해서 가상 머신을 필요한 만큼 실행한다.
4. virt-manager가 사용이 끝난 가상 머신을 삭제한다.

virt-manager는 가상 머신을 대상으로 다음과 같은 조작이 가능하다.
- 각 가상 머신에 준비된 창을 사용해서 가상 머신의 디스플레이 출력을 표시
- 키보드나 마우스를 사용해서 가상 머신의 키보드나 마우스를 조작
- 가상 머신의 전원 끄기, 켜기, 재시작을 처리
- 가상 머신의 장치 추가, 삭제 또는 iso 파일을 가상 DVD 드라이브에 넣고 꺼내기
  
![image](https://github.com/user-attachments/assets/bc8b93e7-a868-4f84-8305-2a40e7005ed4)

## 가상화는 지원하는 CPU 기능
CPU 기능
- 사용자 모드
- 커널 모드

하지만 가상화 기능을 지원하는 CPU의 기능
![image](https://github.com/user-attachments/assets/d9dfa321-149f-4370-8dec-19aa10ea5782)
- VMX-root 모드
  - 사용자 모드
  - 커널 모드
- VMX -nonroot 모드
  - 사용자 모드
  - 커널 모드

레지스터 접근이라고 가정했을 때
- 물리 기기의 장치 접근
  1. 프로세스가 리눅스 커널에 시스템 콜 호출 : 사용자 모드 -> 커널 모드
  2. 리눅스 커널이 레지스터 접근 : 커널 모드 -> 장치
  3. 장치가 리눅스 커널에 응답 : 장치 -> 커널 모드
  4. 리눅스 커널에서 프로세스로 복귀 : 커널 모드 -> 사용자 모드
- 가상 머신의 장치 접근
  1. 가상 머신의 프로세스가 리눅스 커널에 시스템 콜 호출 : 사용자 모드 VMX non-root -> 커널 모드  VMX non-root
  2. 가상 머신의 리눅스 커널이 레지스터 접근으로 인한 모드 전환 : 커널 모드  VMX non-root -> 커널 모드  VMX root
  3. 리눅스 커널의 KVM이 qemu의 하드웨어 에뮬레이션 처리를 통해 가상 레지스터 접근 : 커널 모드  VMX root -> 사용자 모드  VMX root
  4. 가상 레지스터 접근 후 다시 KVM으로 복귀 :  사용자 모드  VMX root -> 커널 모드  VMX root
  5. 모드를 전환하여 가상 머신의 리눅스 커널에 응답 전달 : 커널 모드  VMX root -> 커널 모드  VMX non-root
  6. 가상 머신의 리눅스 커널이 프로세스로 복귀 : 커널 모드  VMX non-root -> 사용자 모드 VMX non-root 
## 가상 머신은 호스트 OS에서 어떻게 보이는가?
이 부분은 실험하려고 했으나
일단 나의 프리티어 ec2에서는 중첩 가상화가 불가능한 상황이었다

책에 따르면 virt-manager의 GUI기능을 통해서 직접 가상 머신을 작성할 수 있다고 한다.
```
virt-install --name ubuntu2004 --vcpus 1 --cpuset=0 --memory 8192 --os-variant ubuntu20.04 --graphics none --extra-args 'console=ttyS0 --- console-ttyS0' --location http:us.archive.ubuntu.com/ubuntu/dists/focal/main/installer-arm64/
```
- 각 옵션 설명:
 - ```--name ubuntu2004``` 설명: 가상 머신의 이름을 지정합니다. 여기서는 ubuntu2004라는 이름을 가진 가상 머신이 생성됩니다.
 - ```--vcpus 1```: 설명: 가상 머신에 할당할 가상 CPU의 수를 지정합니다. 여기서는 1개의 가상 CPU를 사용합니다.
 - ```--cpuset=0```: 설명: 가상 머신에 할당할 물리 CPU의 번호를 지정합니다. 0은 첫 번째 물리 CPU를 가리킵니다. 즉, 이 옵션은 가상 머신이 물리 CPU 0에서만 실행되도록 제한하는 역할을 합니다.
 - ```--memory 8192```: 설명: 가상 머신에 할당할 메모리 양을 지정합니다. 여기서는 8192MB(8GB)의 메모리를 가상 머신에 할당합니다.
 - ```--os-variant ubuntu20.04```: 설명: 가상 머신에서 사용할 운영체제의 종류를 명시합니다. 이는 가상 머신에 최적화된 설정을 적용하기 위해 사용됩니다. 여기서는 ubuntu20.04를 지정하여 Ubuntu 20.04에 맞는 설정을 적용합니다.
 - ```--graphics none```: 설명: 가상 머신에서 그래픽 디스플레이를 사용하지 않도록 설정합니다. 이 경우 가상 머신은 GUI 없이 텍스트 기반의 콘솔만 사용하게 됩니다.
 - ```--extra-args 'console=ttyS0 --- console=ttyS0'```: 설명: 추가 커널 인수(extra kernel arguments)를 지정합니다.
    ```console=ttyS0```: 시리얼 콘솔을 활성화하는 인수입니다. 이는 가상 머신이 부팅하는 동안 시리얼 포트 ttyS0를 통해 콘솔 출력을 보내도록 지정합니다.
     이 설정은 일반적으로 그래픽 디스플레이 없이 텍스트 기반의 시리얼 콘솔로 가상 머신을 제어할 때 사용됩니다.
- ```--location http://us.archive.ubuntu.com/ubuntu/dists/focal/main/installer-arm64/```: 설명: 설치할 운영체제의 설치 이미지를 위치로 지정합니다. --location 옵션은 네트워크 경로를 통해 설치 이미지를 제공할 때 사용됩니다.
   여기서는 Ubuntu 20.04 LTS (Focal Fossa)의 ARM64 설치 이미지를 가리키는 URL을 사용하고 있습니다.
   가상 머신을 설치할 때, 이 URL에서 운영체제 설치 파일을 다운로드하여 설치가 진행됩니다.

```
virsh dumpxml ubuntu2004
```
virt-manager가 작성한 가상 머신의 정체를 확인할 수 있다.

### 호스트 OS본 게스트 OS
가상 머신은 qemu-system-x86_64 프로세스에 일대일로 대응

그래서 전체적인 플로우는
1. 사람이 virt-manager를 통해서 가상 머신 생성
2. 그러면 virt-manager가 파일 시스템에 가상 머신 정의용 xml 작성
3. virt-manager가 위 xml파일을 참조해서 가상 저장 장치 작성
4. 그리고 virsh가 가상 머신의 xml 파일 내용을 qemu-system-x86_64명령어가 해석할 수 있는 형태로 변환해서 인수로 전달
5. virt-manager가 가상 머신 기동 = qemu-system-x86_64(가상 머신의 실체)

=> 이렇게 virt-manager가 가상 머신 작성, 정의 변경, 기동 조작 등은 모두 내부적으로 libvirt 라이브러리를 사용하고 있는 것 따라서 IaaS의 오토 스케일링도 시스템 부하를 감지하면 저 라이브러리를 통해서 오토 스케일릉 진행한다고 한다.

## 가상화 환경과 프로세스 스케줄링
> 사실은 가상 머신에 있는 각 VCPU는 가상 머신에 대응하는 qemu-system-x86 프로세스의 스레드(커널스레드)가 됩니다.

이 부분이 이해되지 않았는데 결국 하나의 가상 머신에 4개의 VCPU가 있는 경우 가상 머신이라는 하나의 프로세스가 4개의 스레드를 생성한다는 의미로 해석되었다.
갑자기 그래서 JVM과 연관지어 생각하게 되었는데 JVM의 VCPU가 없는 거 같다는 생각이 들었고 Java 자체가 생성하는 스레드는 사용자 스레드임에도 커널 스레드와 일대일 매칭되는 거 같다.

이 부분은 뒷쪽에 더 알아본 내용으로 추가할 예정이다. 
![image](https://github.com/user-attachments/assets/8f1a2aa7-72b5-4b19-b0d4-18963822e21f)

## 가상 머신과 메모리 관리
![image](https://github.com/user-attachments/assets/36f93e65-23ff-461b-a0c9-ffaff570c1c6)

## 가상 머신과 저장 장치
가상 머신의 저장 장치는 물리 기기의 파일 또는 저장 장치와 관련이 있다.

```
virsh dumpxml ubuntu2004
```
위 명령어를 통해서 가상 머신에 대한 설정 파일을 확인해보면 
/var/lib/libvirt/images/ubuntu2004.qcow2가 가상 디스크를 저장하는 파일명이라는 것을 확인할 수 있다.
이런 파일은 디스크 이미지라고 부른다.

### 가상 머신과 저장소 입출력
![image](https://github.com/user-attachments/assets/44c42352-f2a5-445e-b717-1bfab3a31a2f)

그림을 통해서도 확인되지만 가상 머신에서의 저장소 입출력은 성능이 나쁘다.
따라서 KVM은 반가상화 기능을 사용해서 저장소 입출력 속도를 향상시키는 기능이 있다.

그렇지만 꼭 그런 것은 아니고 역전 현상이 발생할 수 있다.
어떤 내용을 저장 장치에 쓰고 읽는다고 가정했을 때 가상 머신의 입출력 캐시 옵션이 페이지 캐시에 있는 데이터를 읽을 수 있으면 물리 기기의 입출력 성능보다 좋을 수도 있다.

가상 머신의 디스크 이미지는 물리 기기의 파일시스템에 저장되기 때문에 물리기기의 저장소 입출력 성능에도 영향을 끼친다.
따라서 같이 공유하지 않고 저장 장치 하나를 통째로 가상 디스크 이미지로 사용하는 경우가 자주 있다고 한다.

### 저장 장치 쓰기와 페이지 캐시
여기서 이렇게 말하는 구문이 있다.
>사실 이건 libvirt 설정에 따라 달라집니다. 이런 설정은 장치별로 존재하는 <driver> 태그에 있는 캐시 속성으로 지정합니다. 캐시 속성은 페이지 캐시와 혼동하기 쉬우므로 책에서는 입출력 캐시 옵션이라고 부르겠습니다.

이해되지 않았는데 다시 정리해보니 아래와 같다.
- 입출력 캐시: 가상 머신이 디스크에 데이터를 쓸 때, 데이터를 실제 디스크에 기록하기 전에 먼저 메모리에 저장해놓는 방식입니다. 이 과정에서 캐시를 사용하면 디스크 입출력 성능이 향상될 수 있습니다.
- 페이지 캐시: 리눅스 시스템에서 사용되는 일반적인 캐시 방식으로, 데이터를 디스크에서 읽어올 때 미리 메모리에 저장해 두는 기능입니다.
- 책에서 구분: 책에서는 입출력 캐시와 리눅스의 페이지 캐시를 혼동하지 않도록 입출력 캐시 옵션이라는 용어를 사용하고 있습니다. 이는 가상 머신의 디스크 입출력 처리에 대한 캐시 설정을 말하는 것이지, 리눅스 커널의 일반적인 메모리 관리 방식인 페이지 캐시와는 다르다는 점을 강조하는 것입니다.

입출력 캐시 옵션
- writeback : 페이지 캐시에 쓰고 나중에 한번에 반영 (생각해보니 이노디비 버퍼에서 더티 페이지 한번에 반영하는 방식과 비슷)
- writethrough : 즉시 디스크에 반영 ( 이노디비 버퍼에서 유니크 키가 있는 경우 중복 여부를 확인하기 위해 더티페이지 사용하지 못하고 바로 반영한다는 부분과 비슷)

### 반가상화 장치와 virtio-blk
앞서 가상 머신의 저장소 입출력에 느려서 반가상화를 활용할 수 있다라는 내용이 언급되었다.
> 반가상화란, 가상 머신에서 하드웨어를 완전히 에뮬레이션하는 대신에 가상화 소프트웨어와 가상 머신이 특별한 인터페이스로 접속해서 성능을 개선하는 기술이다. 이 기술을 사용하는 저장 장치를 반가상화 장치, 그런 디바이스 드라이버를 반가상화 드라이버라고 부른다.

책에서는 반가상화 드라이버로 virtio-blk 드라이버를 설명한다.

virtio-blk의 처리 방식
1. 게스트 os의 virtio-blk 드라이버 큐에 명령어 삽입
2. virtio-blk 드라이버에서 호스트 os에 제어를 넘긴다.
3. 호스트 os의 가상화 소프트웨어가 큐에서 명령어를 꺼내서 처리한다.
4. 가상화 소프트웨어가 가상 머신에 제어를 넘긴다.
5. virtio-blk장치는 명령어 실행 결과를 받는다.


물리기기 및 완전 가상화 장치에서의 저장 장치 쓰기 작업은 아래와 같은 3번의 작업이 필요하다.
1. 메모리의 어느 곳에 위치한 데이터를 어떤 크기로 쓰기 작업을 해야하는지 장치에 지시
2. 장치의 어느 위치에 쓰기를 할지 장치에 지시
3. 처리 1번과 처리 2번에서 지정하대로 메모리에서 장치로 데이터를 기록하도록 장치에 지시

장치에 접근할 때마다 CPU 모드의 전환 : vmx non-root 모드 -> vmx root 모드 -> vmx non-root 모드

![image](https://github.com/user-attachments/assets/c9f9ce66-b114-4e3c-bb7e-a0f8e97423f3)


## 느낀점
이제야 자바의 가상 머신의 구조가 이해되었다.
왜 자바의 가상 머신이 본인의 메모리 구조를 가지고 있는지, 생각해보게 되었다.

그래서 가상 머신과 자바 가상 머신에 대해서 찾아보게 되었다.

1. 가상 머신(VM):
- 정의: 가상 머신은 물리적인 하드웨어를 추상화하여 소프트웨어적으로 컴퓨터 시스템을 에뮬레이션하는 환경입니다. 이를 통해 하나의 물리적 컴퓨터에서 여러 개의 가상 컴퓨터(가상 머신)를 동시에 운영할 수 있습니다. 각 가상 머신은 독립된 운영체제를 실행하며, 물리적 하드웨어처럼 작동합니다.

- 목적: 가상 머신(VM)의 주 목적은 하드웨어의 추상화입니다. 물리적 컴퓨터의 자원을 가상화하여 여러 운영체제를 동시에 실행하거나, 특정 환경을 격리하여 사용할 수 있게 합니다.

- 동작 방식: 가상 머신은 CPU, 메모리, 디스크 등 물리적인 하드웨어 자원을 소프트웨어적으로 가상화하여, 여러 운영체제와 애플리케이션을 물리적으로 분리된 환경에서 실행할 수 있게 합니다.

2. 자바 가상 머신(JVM):
- 정의: 자바 가상 머신(JVM)은 자바 프로그램을 실행하기 위한 가상 환경입니다. JVM은 자바 바이트코드(Java bytecode)를 실행하여 자바 프로그램이 어떤 운영체제에서든 동일하게 동작할 수 있도록 합니다. 이는 자바의 "Write Once, Run Anywhere" 철학을 가능하게 합니다.

- 목적: JVM의 목적은 프로그램의 플랫폼 독립성을 제공하는 것입니다. 자바 프로그램은 운영체제나 하드웨어에 종속되지 않고 JVM이 설치된 어느 환경에서든 실행될 수 있습니다.

- 동작 방식: 자바 컴파일러는 자바 소스 코드를 바이트코드로 변환하고, 이 바이트코드는 JVM에서 해석되어 실행됩니다. JVM은 바이트코드를 읽고, 이를 운영체제나 하드웨어가 이해할 수 있는 명령어로 변환하여 실행합니다.

이렇게 가상 머신과 자바 가상 머신 모두 추상화를 통해 하드웨어 또는 운영체제에 의존하지 않는 실행 환경을 제공한다는 점에서 연관이 있지만, 가상화하는 대상과 목적은 다릅니다. VM은 하드웨어를 가상화하고, JVM은 프로그램 실행 환경을 가상화한다는 차이점이 있습니다.

다시 정리하면 자바 가상 머신은 우리가 작성한 프로그램이 운영체제에 독립적으로 만드는 것이다. 따라서 JVM 자체는 운영체제 맞는 것을 설치해야 한다.
바이트코드 해석: 자바 프로그램이 실행되면, JVM은 바이트코드를 운영체제가 이해할 수 있는 기계어로 실시간으로 해석(또는 컴파일)하여 실행합니다. 이때 JVM은 운영체제와 하드웨어의 차이를 추상화하여 바이트코드가 독립적으로 실행되게 합니다.



