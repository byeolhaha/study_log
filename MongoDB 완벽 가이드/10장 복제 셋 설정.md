# 복제 10장
데이터의 동일한 복사본을 만들어 여러 서버상에서 보관하는 방법이며 한대의 서버에 문제가 발생했을 때 이를 대비하기 위한 방법

- 한 대의 프라이머리와 여러 대의 세컨더리
- 프라이머리가 죽으면 세컨더리 중에서 프라이머리 선출
  - 선출할 때 과반수, 우선순위, 최근의 데이터를 가지고 있는지 등을 고려해서 선출한다.
- 복제 셋 소개, 복제 설정하는 방법

## 복제 셋 설정 1
1. 3개의 폴더 만들기
   ```
   mkdir -p ~/data/rs{1,2,3}
   ```
2. 별도 터미널에서 복제 셋의 이름과 데이터베이스 파일이 저장될 경로, 포트 등 설정
   ```
   mongod --replSet mdbDefGuide --dbpath ~/data/rs1 --port 27018 --logpath ~/data/rs1/mongod.log
   ```
   ```
   mongod --replSet mdbDefGuide --dbpath ~/data/rs3 --port 27020 --logpath ~/data/rs3/mongod.log
   ```
   ```
   mongod --replSet mdbDefGuide --dbpath ~/data/rs2 --port 27019 --logpath ~/data/rs2/mongod.log
   ```

## 네트워크 고려사항
복제 셋의 각 멤버가 다른 멤버와 통신하려면 bind_ip 설정이 필요하다.
예전에 몽고컴패스에서 접속하기 위해 bind_ip를 수정한 기억을 떠올리면 될 거 같다.

나 같은 경우 모두 로컬호스트(몽고DB 3.6의 기본)여서 별도의 설정은 하지 않았다.
하지만 그렇지 않고 별도 다른 서버와도 통신하려면 아래와 같이 설정한다.
```java
mongod --bind_ip localhost, 192.51.100.1 --replSet mdbDefGuide \ --dbpath ~/data/rs1 --port 27017 
```

이외의 IP 주소와 통신할 때 암호화 등 고려해야 하는데 이는 19장에서 배운다고 한다.

## 복제 셋 설정 2
다른 터미널에서 접속해보자 
책에서는 mongo 접속하는데 최신 버전에서는 mongosh로 접속이 가능하다.
```
mongosh --port 27019
```

복제셋을 형성한다.
![image](https://github.com/user-attachments/assets/1cec51b6-ef60-4737-bc34-84856c03a86d)

상태를 출력해보자
```java
mdbDefGuide [direct: secondary] test> rs.status()
{
  set: 'mdbDefGuide',
  date: ISODate('2024-09-09T03:58:01.681Z'),
  myState: 1,
  term: Long('1'),
  syncSourceHost: '',
  syncSourceId: -1,
  heartbeatIntervalMillis: Long('2000'),
  majorityVoteCount: 2,
  writeMajorityCount: 2,
  votingMembersCount: 3,
  writableVotingMembersCount: 3,
  optimes: {
    lastCommittedOpTime: { ts: Timestamp({ t: 1725854277, i: 1 }), t: Long('1') },
    lastCommittedWallTime: ISODate('2024-09-09T03:57:57.927Z'),
    readConcernMajorityOpTime: { ts: Timestamp({ t: 1725854277, i: 1 }), t: Long('1') },
    appliedOpTime: { ts: Timestamp({ t: 1725854277, i: 1 }), t: Long('1') },
    durableOpTime: { ts: Timestamp({ t: 1725854277, i: 1 }), t: Long('1') },
    lastAppliedWallTime: ISODate('2024-09-09T03:57:57.927Z'),
    lastDurableWallTime: ISODate('2024-09-09T03:57:57.927Z')
  },
  lastStableRecoveryTimestamp: Timestamp({ t: 1725854251, i: 4 }),
  electionCandidateMetrics: {
    lastElectionReason: 'electionTimeout',
    lastElectionDate: ISODate('2024-09-09T03:56:47.796Z'),
    electionTerm: Long('1'),
    lastCommittedOpTimeAtElection: { ts: Timestamp({ t: 1725854196, i: 1 }), t: Long('-1') },
    lastSeenOpTimeAtElection: { ts: Timestamp({ t: 1725854196, i: 1 }), t: Long('-1') },
    numVotesNeeded: 2,
    priorityAtElection: 1,
    electionTimeoutMillis: Long('10000'),
    numCatchUpOps: Long('0'),
    newTermStartDate: ISODate('2024-09-09T03:56:47.868Z'),
    wMajorityWriteAvailabilityDate: ISODate('2024-09-09T03:56:48.419Z')
  },
  members: [
    {
      _id: 0,
      name: 'localhost:27018',
      health: 1,
      state: 2,
      stateStr: 'SECONDARY',
      uptime: 84,
      optime: { ts: Timestamp({ t: 1725854277, i: 1 }), t: Long('1') },
      optimeDurable: { ts: Timestamp({ t: 1725854277, i: 1 }), t: Long('1') },
      optimeDate: ISODate('2024-09-09T03:57:57.000Z'),
      optimeDurableDate: ISODate('2024-09-09T03:57:57.000Z'),
      lastAppliedWallTime: ISODate('2024-09-09T03:57:57.927Z'),
      lastDurableWallTime: ISODate('2024-09-09T03:57:57.927Z'),
      lastHeartbeat: ISODate('2024-09-09T03:57:59.868Z'),
      lastHeartbeatRecv: ISODate('2024-09-09T03:58:00.892Z'),
      pingMs: Long('0'),
      lastHeartbeatMessage: '',
      syncSourceHost: 'localhost:27019',
      syncSourceId: 1,
      infoMessage: '',
      configVersion: 1,
      configTerm: 1
    },
    {
      _id: 1,
      name: 'localhost:27019',
      health: 1,
      state: 1,
      stateStr: 'PRIMARY',
      uptime: 3987,
      optime: { ts: Timestamp({ t: 1725854277, i: 1 }), t: Long('1') },
      optimeDate: ISODate('2024-09-09T03:57:57.000Z'),
      lastAppliedWallTime: ISODate('2024-09-09T03:57:57.927Z'),
      lastDurableWallTime: ISODate('2024-09-09T03:57:57.927Z'),
      syncSourceHost: '',
      syncSourceId: -1,
      infoMessage: 'Could not find member to sync from',
      electionTime: Timestamp({ t: 1725854207, i: 1 }),
      electionDate: ISODate('2024-09-09T03:56:47.000Z'),
      configVersion: 1,
      configTerm: 1,
      self: true,
      lastHeartbeatMessage: ''
    },
    {
      _id: 2,
      name: 'localhost:27020',
      health: 1,
      state: 2,
      stateStr: 'SECONDARY',
      uptime: 84,
      optime: { ts: Timestamp({ t: 1725854277, i: 1 }), t: Long('1') },
      optimeDurable: { ts: Timestamp({ t: 1725854277, i: 1 }), t: Long('1') },
      optimeDate: ISODate('2024-09-09T03:57:57.000Z'),
      optimeDurableDate: ISODate('2024-09-09T03:57:57.000Z'),
      lastAppliedWallTime: ISODate('2024-09-09T03:57:57.927Z'),
      lastDurableWallTime: ISODate('2024-09-09T03:57:57.927Z'),
      lastHeartbeat: ISODate('2024-09-09T03:57:59.868Z'),
      lastHeartbeatRecv: ISODate('2024-09-09T03:58:00.892Z'),
      pingMs: Long('0'),
      lastHeartbeatMessage: '',
      syncSourceHost: 'localhost:27019',
      syncSourceId: 1,
      infoMessage: '',
      configVersion: 1,
      configTerm: 1
    }
  ],
  ok: 1,
  '$clusterTime': {
    clusterTime: Timestamp({ t: 1725854277, i: 1 }),
    signature: {
      hash: Binary.createFromBase64('AAAAAAAAAAAAAAAAAAAAAAAAAAA=', 0),
      keyId: Long('0')
    }
  },
  operationTime: Timestamp({ t: 1725854277, i: 1 })
}

```
저 상태를 통해서 누가 프라이머리이고 세컨더리인지 확인이 가능하다.

## 복제 관찰
현재 내가 접속한 localhost:27019가 프라이머리이기 때문에
프롬프트가 변경되었다.
```
mdbDefGuide [direct: primary] test> 
```

프라이머리로 가서 쓰기 작업을 진행한다.
```
mdbDefGuide [direct: primary] post> for(i=0;i<1000;i++){db.coll.insert({count:i})}
DeprecationWarning: Collection.insert() is deprecated. Use insertOne, insertMany, or bulkWrite.
{
  acknowledged: true,
  insertedIds: { '0': ObjectId('66e1c0d906df65c916827b58') }
}
```
insertMany로 진행했어야 했는데 일단 디프리케이티드 되었지만 진행은 되었다.


이 상태에서 다른 세컨더리로 복제가 잘 되었는지 확인하고 싶을 것이다.
확인하려고 세컨더리에 대한 find()를 날리면 책에서는 오류를 뱉는다고 했는데 실제로 그렇지는 않았다.
오류를 뱉는 이유는 세컨더리는 최신화가 뒤쳐지기 때문에 실효 데이터를 읽지 않도록 하기 위함이라고 한다.
![image](https://github.com/user-attachments/assets/88afba80-17f1-4592-a150-3e5b8b553643)

당연하지만 세컨더리에서 클라이언트를 통한 쓰기는 절대 안된다!!

만약에 프라이머리가 중단된다면 세컨더리는 본인들 중에서 프라이머리를 선출한다.
![image](https://github.com/user-attachments/assets/f1a1f1e9-c060-4553-ad2c-0ece9fcaad42)

![image](https://github.com/user-attachments/assets/c5aa7ce5-43f9-4cc2-8bfb-f5f736e75f0a)

원래 localhost:27020이 프라이머리였는데 강제로 셧다운시켰더니 이제 프라이머리가 localhost:27018로 바뀌게 되었다.

## 복제 설정
- 복제셋 추가하기
  ![image](https://github.com/user-attachments/assets/ef060e8b-5e68-49a6-b5ef-4acaeeee3b6d)
  세컨더리에서 추가하는 작업을 진행하면 프라이머리에서 진행하라는 경고가 등장한다.
  ```
  mdbDefGuide [direct: primary] test>  rs.add("localhost:27021")
  ```
  그래서 위와 같이 프라이머리에서 추가하는 작업을 진행해야 한다.
  ![image](https://github.com/user-attachments/assets/880b90cc-6819-4edc-b66b-1bd8778f23fc)
  설정을 바꿀때마다 저 setVersion의 숫자가 증가한다. (1부터 시작)

- 복제셋 삭제하기
  ```
  mdbDefGuide [direct: primary] test>  rs.remove("localhost:27021")
  ```
