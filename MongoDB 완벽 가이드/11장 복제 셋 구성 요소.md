# 복제 셋 구성 요소
전체적인 흐름
- 복제 셋 멤버가 새로운 데이터를 복제하는 방법
- 새로운 멤버를 영입하는 방법
- 선출이 작동하는 방법
- 발생할 수 있는 서버 및 네트워크 오류 시나리오
## 동기화
- 복제는 여러 서버에 걸쳐 데이터의 복사본 보관
- 몽고 DB는 프라이머리가 수행한 쓰기를 모두 포함하는 로그인 **oplog**를 보관하고 있다.
- oplog는 프라이머리의 로컬 데이터베이스에 있는 제한 컬렉션이다.
- 세컨더리는 이 oplog 컬렉션을 바탕으로 연산을 쿼리한다. 따라서 세컨더리들도 본인들의 oplog를 가지고 있다.
- 근데 이게 연쇄적이다. 그림으로 보면 아래와 같다. 멤버들끼리 누군가의 oplog를 쫓고 있다.
![image](https://github.com/user-attachments/assets/1054177a-243b-4c06-bc0d-5f1e383d4a77)

- oplog의 각 연산은 멱등하다. 따라서 한번 수행하나 여러 번 수행하나 결과는 같다.
  세컨더리가 어떤 사유로 다운되어 재시작 될 때 마지막 연산과 동기화한다.
- oplog의 크기는 고정적이다. 따라서 담을 수 있는 연산의 수가 정해져 있다.
  - 쓰기 연산 한번의 크기 = oplog 한번 연산의 크기
  - 하지만 쓰기 연산 한번이 다중 쓰기나 다중 삭제라면 oplog는 여러 개의 연산으로 분리된다.
  - 일반적으로 기본 크기로는 충분하다

#### oplog 크기가 기본 크기보다 커야하는 경우
- 한 번에 여러 도큐먼트 갱신
- 삽입한 데이터와 동일한 양의 데이터 삭제
- 상당한 수의 내부 갱신

## 몽고DB 동기화
- 초기 동기화
- 전체 데이터셋에 지속적인 변경 사항을 적용하는 복제
### 초기 동기화
>컴퓨터 시스템이나 네트워크, 데이터베이스 등에서 데이터나 상태를 처음으로 동기화하는 과정을 의미한다.
주로 클라이언트와 서버 간에 데이터의 일관성을 맞추기 위해 수행되며, 두 시스템이 동일한 데이터나 상태를 유지하도록 하는 첫 번째 단계
초기 동기화가 필요한 이유는 시스템 간 데이터 불일치가 발생하지 않도록 하기 위함입니다. 이를 통해 데이터 손실이나 오류를 방지하고, 시스템 간 신뢰성을 높일 수 있습니다.
이후에는 주기적으로 동기화가 진행되며, 변경된 데이터만 업데이트하는 증분 동기화(incremental synchronization)가 수행될 수 있습니다.

몽고DB는 로컬 데이터베이스를 제외한 모든 데이터베이스를 복제한다.
<mark style="background-color:#fff5b1"> 대상 멤버의 기존 데이터는 복제작업을 시작하기 전에 모두 삭제된다는 점을 유의하자</mark>

- 몽고DB 3.4 및 이후 버전에서는 각 컬렉션에서 도큐먼트가 복사될 때 초기 동기화가 모든 컬렉션 인덱스도 구축
- 복사 중에 새로 추가된 oplog 레코드를 가져오기 때문에 대상 멤버가 데이터를 복사 단계에서 레코드를 저장한 충분한 디스크 공간이 로컬 데이터베이스에 있는지 확인
- 이렇게 모두 복사하면 초기 동기화 단계에서 일반 동기화 단계로 넘어간다.

#### 초기 동기화 vs. 백업으로부터의 복원
책에서 읽다가 그럼 둘의 개념 차이가 뭔가에 대한 의문이 들어서 챗gpt에 물어봤다.
```
1. 복제 셋 (Replica Set)
복제 셋은 MongoDB에서 고가용성과 데이터 무결성을 보장하기 위한 기능입니다. 복제 셋은 여러 서버(노드)로 구성된 그룹으로, 한 노드(primary)가 데이터의 쓰기와 읽기를 처리하고, 나머지 노드(secondary)는 그 데이터를 실시간으로 복제해 동기화합니다.

복제 셋의 주요 목적은 다음과 같습니다:
- 실시간 복제: 기본(primary) 노드에서 데이터가 변경되면, 보조(secondary) 노드들이 이를 실시간으로 받아 복제합니다. 따라서 데이터를 지속적으로 동기화 상태로 유지할 수 있습니다.
- 장애 복구: 기본 노드가 장애를 겪을 경우, 보조 노드 중 하나가 자동으로 기본 노드로 승격되어 서비스를 지속적으로 제공할 수 있습니다.- -
- 데이터 가용성: 복제 셋을 사용하면 여러 노드에 데이터가 분산 저장되어, 특정 서버가 다운되더라도 다른 노드에서 데이터를 사용할 수 있습니다.
2. 백업
백업은 특정 시점의 데이터를 저장해두는 방식으로, 데이터 복구가 목적입니다. MongoDB에서 백업은 수동 또는 자동으로 생성할 수 있으며, 시스템 오류나 데이터 손상, 사용자의 실수로 데이터를 잃어버렸을 때 복원하는 데 사용됩니다. 백업은 스냅샷처럼 특정 시점의 데이터 상태를 보존하는 역할을 하며, 보통 장기 보관을 목적으로 합니다.

백업의 주요 특징:
- 데이터 보존: 일정한 시점의 데이터 상태를 저장해두어 나중에 복구할 수 있습니다.
- 데이터 손실 복구: 실수로 삭제된 데이터나 손상된 데이터를 복구하는 데 사용됩니다.
- 일반적으로 정적: 실시간으로 데이터가 업데이트되는 복제 셋과 달리, 백업은 특정 시점의 데이터를 그대로 저장합니다.
차이점 요약
복제 셋은 실시간 데이터 동기화와 고가용성을 위한 구조입니다. 즉, 데이터가 계속 변경되는 환경에서 데이터를 동기화하며, 시스템 장애 시 즉각적인 복구를 가능하게 합니다.
백업은 데이터 손실에 대비해 일정 시점의 데이터를 보존하는 방식으로, 실시간 동기화가 아닌 정적 데이터 복구를 위한 것입니다.
결론:
복제 셋을 사용하는 것은 실시간 동기화와 시스템 장애 시의 무중단 운영을 위한 것이며, 백업은 장기적인 데이터 복구나 데이터 손상 복구를 위한 방법입니다. 따라서 복제 셋과 백업은 서로 보완적인 역할을 하며, 복제 셋을 사용하더라도 백업은 별도로 관리하는 것이 일반적입니다. 즉, 복제 셋을 운영하는 것과 백업을 사용하는 것은 다릅니다.
```

- 위 내용에 따라 백업으로부터의 복원이 모든 데이터를 복사하는 초기 동기화보다 더 빠르며 더 바람직하다.
- 초기 동기화(복제)는 결국 자주 조회되는 데이터에 대해서 메모리에 올리거나 캐시를 했을 텐데 초반에는 그런 것들이 적용되어져 있지 않다보니 느려질 수 있다.
- <mark style="background-color:#fff5b1"> 둘 다 한가한 시간에 하자 oplog보다 뒤처질 수 있다.</mark>

### 전체 데이터셋에 지속적인 변경 사항을 적용하는 복제
- 세컨더리 멤버는 초기 동기화 후 지속적으로 데이터를 복제한다.
- 비동기 프로세스 적용하여 oplog 복제
- 특정 노드가 다른 어떤 멤버를 동기화할 수 있는지는 몇 가지 규칙이 있다.
  - 투표수가 1인이 복제 셋 멤버는 0인 멤버와 동기화 x
  - 세컨더리는 지연된 멤버나 숨겨진 멤버와 동기화 하지 않는다.
 
### 실효 처리
> 세컨더리가 동기화 소스상에서 수행된 실제 연산들보타 훨씬 뒤처진다면 실효 상태가 된다.
동기화 코드의 모든 연산이 실효 세컨더리보다 훨씬 앞서기 때문에 따라잡는 것은 불가능하다.

- 그러다 보면 일부 작업을 건너뛰게 된다.
  - 이는 세컨더리가 다운타임 중
  - 쓰기 요청이 처리량을 뛰어넘거나
  - 읽기 작업이 매우 바쁠 때 발생
- 실효 상태가 되면 복제 셋의 각 멤버로부터 차례대로 복제 시도
- 충분히 긴 oplog를 갖는 멤버가 있는지 확인 => 만약에 이를 발견하지 못하면 세컨더리의 복제는 중지되고 다시 재기동
- 따라서  **<mark style="background-color:#fff5b1"> 프라이머리는 큰 oplog크기를 가져야한다. 그래야 세컨더리가 동기화되지 못해 재기동되는 문제를 피할 수 있다.</mark>** 디스크 공간은 저렴하고 크기가 커서 괜찮다. 보통 2~3일 분량의 정상적인 연산을 저장할 수 있는 범위로 제공하자

## 하트비트
앞서 10장에서 복제 셋의 멤버들은 2초마다 서로에게 하트비트(핑퐁)을 던져서 유효한 상태인지 체크한다고 하였다.
가장 중요한 기능은 프라이머리에게 과반수 도달 여부를 전달해주는 것이다. 만약에 과반수보다 적다면 프라이머리는 존재하지 않은 상태로 변경된다. 즉 프라이머리는 세컨더리로 강등되며 어떤 복제 셋도 프라이머리가 될 수 없다.

### 하트비트를 통해서 멤버들끼리 주고 받는 상태
세컨더리와 프라이머리 외에 일반적인 상태는 아래와 같다.

#### 일반적인 상태
- STARTUP : 멤버 처음 시작할 때의 상태, 멤버의 복제 셋 구성 정보 로드를 시도할 때
- STARTUP2 : 초기 동기화 과정 전반에 걸쳐 지속, 일반적으로 단 몇 초 동안 지속
- RECOVERING : 멤버가 현재 올바르게 작동, but 읽기 작업을 수행할 수 없음 , 조금 과부화 된 상태
  - 시작하고 세컨더리가 되기 전에 짧게 RECOVERING 상태가 될 수 있음
  - 조각 모음 같은 긴 연산이 진행되거나 replSetMaintenance 명령에 대한 응답으로  RECOVERING 상태가 될 수 있음.
      ```
      - 조각 모음: MongoDB에서 조각 모음(defragmentation) 작업은 디스크 공간을 효율적으로 사용하기 위해 데이터 파일을 최적화하는 과정입니다. 이 과정에서 긴 연산이 발생할 수 있고, 노드가 잠시 동안 "RECOVERING" 상태로 전환될 수 있습니다. 이 상태에서는 읽기 및 쓰기 작업이 제한되거나 차단됩니다.
      - replSetMaintenance 명령: MongoDB 복제 셋(replica set)에서 replSetMaintenance 명령을 사용하면 해당 노드를 유지보수 모드로 전환할 수 있습니다. 이 상태에서도 노드는 클러스터에서 정상적으로 동작하지 않고, 복구 작업이 끝날 때까지 "RECOVERING" 상태가 됩니다. 이 상태에서는 해당 노드가 클러스터 내에서 주 노드로 승격되거나, 일부 데이터 요청을 처리하지 못할 수 있습니다.
      ```
  - 실효 상태가 되었지만 곧 긴 oplog를 발견해 복구될 것을 기대하고 잇을 때
- ARBITER : 앞 서 배운 아비터이다.
#### 시스템상 문제인 상태
- DOWN : 멤버가 살아있지만 도달할 수 없는 상태 => 예를 들어 살아는 있지만 네트워크 문제로 도달할 수 없는 상태임
- UNKOWN : 한번도 도달한 적이 없어서 어떤 상태인지 알 수 없음
- REMOVED : 멤버가 복제셋으로부터 제거된 상태
- ROLLBACK : 롤백할 때 사용

## 롤백

