# 애플리케이션에서 복제 셋 연결
애플리케이션이 어떻게 복제 셋과 상호작용하는지 이 방법에 대해서 배운다.
- 연결 및 장애 조치를 수행하는 방법
- 쓰기 시 복제 대기하는 방법
- 올바른 멤버에 읽기 요청을 라우팅하는 방법

## 클라이언트 - 복제 셋 연결 동작
- 몽고DB 클라이언트 라이브러리(=드라이버)는 서버가 어떤 형태(독립 실행형 or 복제 셋)인지 관계없이 몽고DB 서버와 통신할 수 있도록 설계
- 복제 셋이면 기본적으로 드라이버는 프라이머리와 연결-> 모든 트래픽을 프라이머리로 라우팅한다.
- 드라이버<-MongoClient를 통해 시드 목록(서버 주소의 목록)을 제공하자. 근데 시드가 하나만 제공해도 서로 연결되어 있어 찾을 수 있다.
  추가적으로 DNS 시드 목록으로 제공하면 클라이언트를 재구성할 필요가 없다.
  ```
  mongodb://server-1:27017,server-2:27017,server-3:27017
  ```

앞서 배웠지만 프라이머리가 다운된다면 다음 프라이머리를 산출하고 그 과정동안 어떤 요청도 받지 않는다. 단, 세컨더리로 읽기 요청만 가도록 설정할 수는 있다.
근데 생각해봐야할 부분은 **드라이버는 프라이머리가 다운됨을 연살 실패로 알게 될 때가 많고 이는 프라이머리가 다운되기 전에 해당 연상을 수행했는지 여부를 드라이버가 알지 못한다는 것이다.**
여기서 연산 실패는 두 가지 상황을 말할 수 있다.
1. 정말 연산이 실패(응답까지 받음) -> 프라이머리 다운 => fail 😨
2. 연산 수행 -> 프라이머리 다운 -> 연산에 대한 응답을 받지 못함 => fail 😨

따라서 연산을 수행했는지 안했는지 알 수가 없다.


그래서 이에 대한 전략과 어떤 오류가 발생할 수 있는지 생각해보자
- 전략
  - 재시도 하지 않기
  - 일정 횟수만큼 재시도하기 그래도 실패하면 포기하기
  - 딱 한번만 재시도하기
- 오류
  - 일시적인 네트워크 오류
  - 지속적인 운영 중단
  - 잘못된 것으로 간주하여 거부하는 것

책에서 한 예시를 들어서 각 전략과 오류에 대해서 설명한다.
"단순히 카운트를 증가시키는 쓰기"
- 쓰기를 재시도 하지 않는 전략
  - 일시적인 네트워크 오류 : 과소 계산
  - 지속적인 운영 중단 혹은 명령 오류 : 올바른 선택
- 고정 횟수만큼 재시도하는 전략
  - 일시적인 네트워크 오류 : 초과계산
  - 지속적인 운영 중단 혹은 명령 오류 : 그저 사이클의 낭비
- 한 번만 재시도하는 전략
  - 일시적인 네트워크 오류 : 초과계산
  - 지속적인 운영 중단 혹은 명령 오류 : 올바른 전략

=> 멱등성을 보장할 수 있다면 고정 횟수이든 한번이든 언제가 같은 결과가 나오기 때문에 올바르게 처리할 수 있다.

> 몽고DB 3.6부터 서버와 모든 몽고DB 드라이버는 재시도 가능한 쓰기 옵션을 지원한다. **재시도 가능한 쓰기라면 드라이버는 자동으로 최대 한 번 재시도하는 전략을 따른다.**

실제로 Java에서 MongoClient를 통해서 어떻게 재시도 가능한 쓰기 옵션을 설정할 수 있는지 예시를 찾아보았다.
```java
MongoClientSettings settings = MongoClientSettings.builder()
    .applyConnectionString(new ConnectionString("mongodb://localhost:27017/?retryWrites=true"))
    .build();
MongoClient mongoClient = MongoClients.create(settings);
```

책에 이해가 되지 않는 부분이 있었는데 바로 이 부분이다.
>재시도 가능한 쓰기를 설정하면 서버는 각 쓰기 연산에 대해 고유한 식별자를 유지하고 따라서 이미 성공한 명령을 드라이버가 재시도하는 시기를 확인할 수 있다. 쓰기를 다시 적용하는 대신 쓰기가 성공함을 나타내는 메시지를 반환함으로써 일시적인 네트워크 문제로 인한 문제를 극복한다

그래서 챗gpt에 물어보았고 아래 내용을 읽어보니 카프카에서 중복 메시지를 처리하는 방식과 비슷한 방식임을 깨달았다.
![image](https://github.com/user-attachments/assets/ede192c6-4205-40b4-8743-d440e0dc08e4)

## 쓰기 시 복제 대기하기
이 문제는 앞서 11장에서 다룬 내용인데 그것에 대한 해결책을 제시하고 있었다.

뭐냐면 마지막 연산이 프라이머리에 반영되었지만 세컨더리는 이 연산을 복제하지 못했고 이 상황에서 프라이머리가 다운되는 것이다. 그러면 세컨더리 중에서 프라이머리를 선출하게 될텐데 이렇게 새로 선출된 프라이머리가 마지막 연산을 알지 못하므로 
이전 프라이머리가 다시 살아나게 된다면 그 마지막 연산이 롤백되는 것이다.

하지만 이 롤백이 서비스의 성격에 따라 치명적일 수 있다. 그래서 수동으로 롤백을 반영할 수도 있지만 이는 기존 데이터와 병합하면서 충돌을 발생시킬 수 있으므로 바람직한 방법이 아니라고 11장에서 설명했다.

따라서 12장에서 설명하는 바람직한 방법은 **과반수에 쓰기를 수행하는 것이다.** 
이러기 위해서는 writeConcern 옵션을 사용한다.

```
try{
 db.products.insertOne(
  {"_id" : 10, "item" : "envelopes" , "qty": 100, type: "Self-Sealing"},
  {writeConcern : {"w" : "majority", "wtimeout":100}}
 );
} catch(e) {
  print(e);
}
```

java 코드를 따로 찾아보았다.
```java
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import com.mongodb.client.model.WriteConcern;
import org.bson.Document;

public class MongoDBExample {
    public static void main(String[] args) {
        // MongoDB 클라이언트 생성
        MongoClient mongoClient = MongoClients.create("mongodb://localhost:27017");

        // 데이터베이스와 컬렉션 선택
        MongoDatabase database = mongoClient.getDatabase("test");
        MongoCollection<Document> collection = database.getCollection("products");

        try {
            // 문서 생성
            Document doc = new Document("_id", 10)
                            .append("item", "envelopes")
                            .append("qty", 100)
                            .append("type", "Self-Sealing");

            // 과반수 쓰기 설정 (WriteConcern.MAJORITY 사용)
            collection.withWriteConcern(WriteConcern.MAJORITY).insertOne(doc);

            System.out.println("Document inserted with majority write concern");
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
        } finally {
            mongoClient.close();
        }
    }
}
```

성공하면 서버는 다음과 같은 응답 메시지를 주는데 이는 쓰기 작업이 과반수의 복제 셋 멤법에 반영이 모두 완료되면 온다.
```
{"acknowledged":true, "insertedId": 10} 
```

또한 지정 시간 (wtimeout)내에 응답하지 않으면 오류를 뱉는다.
### w에 대한 다른 옵션
- writeConcern에는 "majority" 외에도 숫자를 전달할 수 있다.
- 숫자는 몇 개의 서버에 쓰기를 전달할 것인지를 나타내면 항상 프라이머리는 포함된다.

## 사용자 정의 복제 보증
> 과반수 쓰기를 하면 안전하다고 여겨지나 어떤 복제 셋은 요구사항이 더 복잡할 수도 있다.

예를 들어
- 데이터 센터마다 최소 한 개의 서버
- 혹은 숨겨지지 않은 노드의 과반수에 쓰기를 수행
- 사용자 규칙을 만들어 "getLastError"에 넘겨주면 된다.

### 데이터 센터당 하나의 서버 보장하기
- 데이터 센터 간의 문제는 데이터 센터 내 문제보다 훨씬 일반적
- 또한 여러 센터에 동등하게 영향을 주기보다는 하나의 데이터 센터가 오프라인이 되는 경우가 더 많다.
- 따라서 성공 통보를 받기 전에 모든 데이터 센터에 쓰기를 보장하는 것이 좋다.

```
var config = rs.config()
config,members[0].tags = {"dc" : "us-east"}
config.members[1].tags = {"dc" : "us-east"}
config.members[2].tags = {"dc" : "us-east"}
config.members[3].tags = {"dc" : "us-east"}
config.members[4].tags = {"dc" : "us-west"}
config.members[5].tags = {"dc" : "us-west"}

```
  
