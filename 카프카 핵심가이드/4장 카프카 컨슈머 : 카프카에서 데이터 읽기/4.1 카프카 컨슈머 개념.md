## 4.1.1 컨슈머와 컨슈머 그룹
- 컨슈머는 컨슈머 그룹에 속한다.
- 컨슈머 그룹은 여러 개일 수 있으며 이 컨슈머 그룹은 동일한 메시지를 받는다. 그래서 그룹A도 파티션1로부터 메시지 1번을 받고 그룹B도 파티션 1로부터 메시지 1번을 받는다.
## 4.1.2 컨슈머 그룹과 파티션 리벨런스
> 리밸런스: 컨슈머 그룹에 할당된 파티션을 다른 컨슈머에게 할당해주는 작업
- 파티션 할당 전략
  1. 조급한 리밸런스
     - 우선 모든 컨슈머가 자신에게 할당된 파티션을 포기
     - 파티션을 포기한 컨슈머 모두가 다시 그룹에 참여한 뒤에 새로운 파티션을 할당받고 읽기 작업 개제
     - 근본적으로 전체 컨슈머 그룹에 대해 짧은 시간동안 작업을 멈추게 하며 그 시간의 길이는 컨슈머 그룹의 크기와 매개 변수에 영향을 받는다.
  2. 협력적 리밸런스
     - 한 컨슈머에게 할당되어 있던 파티션만을 다른 컨슈머에게 재할당
     - 그래서 재할당되지 않은 파티션에서 레코드를 읽고 멈추지 않고 자기 할 일을 할 수 있다. 조급한 리밸런스에 비해서 스탑더월드가 발생하지 않는다.
     - 이 작업은 크게 두 단계로 일어난다.
       - 컨슈머 그룹 리더가 다른 컨슈머들에게 각자에게 할당된 파티션 중 일부가 재할당 될 것이라고 통보하면 컨슈머들은 해당 파티션에서 데이터를 읽어오는 작업을 멈추고 소유권을 포기한다.
       - 컨슈머 그룹 리더가 이 포기된 파티션들을 새로 할당한다.
     - 이 방식은 컨슈머 그룹이 커서 리밸런싱 시간이 길게 발생될 것으로 예상되는 경우 아주 중요한 부분으로 작용한다.
- 하트비트 = 브로커가 죽은 컨슈머를 알 수 있는 방법
  - 컨슈머는 해당 컨슈머 그룹의 그룹 코디네이터 역할을 지정받은 브러커에게 하트비트를 전송해서 멤버십과 할당된 파티션에대한 소유권을 유지한다.
  - 만약에 이게 일정 시간 오지 않아 세션 타임 아웃이 오면 죽었다고 판단해서 리밸런싱이 일어난다.
- 파티션은 어떻게 컨슈머에게 할당되는가?
  - 일단 컨슈머가 그룹에 참여하고 싶을 때 그룹 코디네이터에게 참여 요청이 JoinGroup 요청을 보낸다.
  - 그러면 처음 요청을 보낸 컨슈머가 리더가 된다. 이 리더는 그룹에 속한 컨슈머들에게 파티션을 할당해주는데 이 할당 방식은 PartitionAssinger 인터페이스 구현체에 의해서 결정된다.
### 4.1.3 정적 그룹 멤버십
- 기본적으로 컨슈머가 갖는 컨슈머 그룹의 멤버로서 자격은 일시적
- 컨슈머가 컨슈머 그룹을 떠나는 수간 해당 컨슈머에 할당되어 있던 파티션들을 해제되고 다시 참여하면 새로운 맴버 ID가 발생되면서 리밸런스 프로토콜에 의해서 새로운 파티션이 할당된다.
- 하지만 컨슈머에게 **고유한 group.instance.id** 를 할당해준다면 컨슈머는 세션 타임아웃이 발생하기 전까지는 해당 컨슈머가 죽어도 그룹을 떠나지 않는다. 그리고 그 사이에 돌아온다면 컨슈머는 기존에 할당받은 파티션을 그대로 사용한다.
- 따라서 리밸런스가 일어나지 않는다. 각 멤버에 대한 파티션 할당을 캐시해두고 그것을 그대로 사용한다.
- 그래서 캐시를 재생산하는 것이 비효율적일 때 사용해볼 수 있다.
- 다만, 컨슈머가 죽었다가 다시 돌아오기까지 해당 파티션에는 메시지가 계속 처리되지 않고 쌓이기 때문에 해당 컨슈머는 돌아오면 밀린 일감을 처리해야 한다. 이 밀린 일감이 제대로 처리되는지 관찰할 필요가 있다.
- 그래서 세션 타임 아웃의 값을 다시 돌아오기까지의 시간이 확보될 수 있는 만큼 길고, 밀린 일감을 처리할 수 있는 만큼의 짧은 시간을 설정하는 것이 좋다.
- 세션 타임 아웃 시간이 지나면 리벨런스가 일어난다. 또한 그 이전에 돌아왔을 때 이미 group.id가 있다면 예외가 던져진다.
