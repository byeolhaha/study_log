# 8.1 디스크 읽기 방식

어떻게 디스크 I/O를 줄이냐가 관건

## 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

SSD

- 저장용 플래터가 아닌 플래시 메모리 장착
- 디스크 원판을 회전할 필요 없이 빨리 데이터를 읽을 수 있다.
- 기존 HDD보다 랜던 I/O가 훨씬 빠르다
- 데이터베이스 서버에서 순차 I/O 작업 << 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업

## 8.1.2 랜덤 I/O와 순차 I/O

![image](https://github.com/user-attachments/assets/4ce98ffe-dbee-437b-88d9-2ae67145e04f)


- 순차 I/O는 3개의 페이지를 디스크에 기록하기 위해서 1번의 시스템 콜
    - 디스크 헤더 1번
- 랜덤 I/O는 3개의 페이즈를 디스크에 기록하기 위해서 3번의 시스템 콜
    - 디스크 헤더 3번
- 디스크에 읽고 쓰는데 걸리는 시간 = 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정
- 따라서 랜덤 I/O가 순차 I/O보다 작업 부하가 훨씬 더 크다

- 디스크 원반을 가지지 않는 SDD
    - 랜덤이나 순차나 차이가 없을까? NO
    - 여전치 랜덤이 순차보다 전체 결과가 떨어진다.

<aside>
📌 **쿼리 튜닝** = 랜덤을 순차로 바꾸는 방법이 그닥 많지 않으므로 이보다는 **랜덤 자체를 줄여주는 것이 목적**

<aside>
🧐 = **`쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것`**

</aside>

</aside>

# 8.2 인덱스란?

key : value

칼럼의 값 : 해당 주소

DBMS의 인덱스는 sortedList와 같이 항상 정렬된 상태를 유지

sortedList의 장단점

- 저장될 때마다 항상 값을 정렬 → 저장하는 과정이 복잡하고 느리다.
- but 아주 빨리 원하는 값을 찾을 수 있다.
- 즉 데이터의 저장 성능을 희생하고 그 대신 읽기 속도를 높이는 기능

### 인덱스를 역할별로 구분

- 프라이머리 키
    - 레코드를 데표하는 칼럼의 값으로 만들어진 인덱스
    - 중복 X, null X
- 프라이머리 키를 제외한 나머지 모든 인덱스 = 세컨더리 인덱스
    - 유니크 인덱스는 프라이머리 키와 비슷하며 대체 가능

### 저장 방식별로 구분

- B-Tree
    - 값을 변형하지 않고 원래의 값을 인덱싱하는 알고리즘
    - R-Tree로 위치 기반 검색이 있으나 이도 B-Tree의 응용이다.
- Hash
    - 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘, 매우 빠른 검색
    - 값을 변형해서 인덱싱하므로 전방 일치와 값의 일부만 검색
    - 범위를 검색할 때는 이용할 수 없음
    - 주로 메모리 기반 DB에서 자주 사용

### 왜 DB 인덱스로 B Tree인가?

데이터를 한 번 찾을 때마다 반씩 없어지는 알고리즘을 O(log n)

이는 Self Balancing Binary Tree도 같다. (AVL이나 RedBlackTree)

하지만 그럼에도 BTree가 선택된 이유는  더 적게 Secondary Storage에 접근하기 때문이다.

인덱스를 읽는 과정은 Secondary Storage에 접근하는 과정이다.

BTree의 경우에는  Self Balancing Binary Tree에 비해서 같은 레벨에서 많은 노드를 가지고 있기 때문에 Secondary Storage에 접근하는 횟수가 적다.

또한 file Sytem에 데이터를 읽어올 때 Block 단위로 읽어오게 된다.

따라서 연관된 데이터를 이 Block 단위 안에 포함시킬 수록 유리한데

Btree의 경우 Block에 관련된 데이터가 Self Balancing Binary Tree에 비해서  노드에 관련된 키를 집약해서 저장하고 있다.

# 8.3 B(Balanced)-Tree 인덱스

**원래의 값을 변형시키지 않고** 인덱스 구조체 내에서는 **항상 정렬된 상태**로 유지한다.

## 8.3.1 구조 및 특징


![image](https://github.com/user-attachments/assets/07df753a-7689-4dda-90c3-c7ab51522220)


- 루트
- 브랜치
- 리프 : 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.

- 인덱스의 키값을 정렬되어 있지만 실제 데이터 파일은 정렬되어 있지 않다.
(SortedList와 ArrayList)
- **데이터 파일의 레코드는 Insert되는 순서대로 저장되는 것이 아니라**
물론 전혀 삭제하지 않고 변경하지 않는다면 True
그러나 **삭제되어 빈 공간이 생기는 경우 그 다음 Insert는 가능한 삭제된 빈 공간을
활용**한다.

MySQL의 InnoDB 테이블은

- 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순으로 정렬되어 저장된다.
- 클러스터링이란 비슷한 값을 최대한 모아서 저장하는 방식

![image](https://github.com/user-attachments/assets/dcd87f30-102b-4576-9611-a4928d932718)


- 프라이머리 키 = ROWID
- MyISAM은 **세컨더리 인덱스가 바로 물리적인 주소**를 가지는 반면
- **InnoDB는 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소**를 가진다.
- 그래서 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못한다.
- **프라이머리 키 인덱스는 데이터 파일에 있다!**
- **한 페이지 내에서 레코드의 검색이 끝난다면 디스크 I/O 1회**

<aside>
🧐 InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 B-Tree를 다시 한번 검색해야 한다.

</aside>

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제

인덱스 키 추가나 삭제가 어떻게 처리되는가 → 쿼리의 성능 예측 가능

인덱스 사용할 때 주의사항

### 인덱스 키 추가

새로운 키 값은 즉시 인덱스 저장될 수도, 안될 수도

저장될 키 값을 이용해 적절한 위치 검색 

→ 저장될 위치가 결정되면 레코드의 키 값과 레코드의 대상 주소 정보를 b-tree 리프 노드에 저장

→ 리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노트 분리, 

→ 이는 상위 브랜치 노드까지 처리의 범위가 넓어짐 

따라서 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 든다.

인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있다.

하지만 중복 체크가 필요한 유니크 인덱스나 프라이머리 인덱스의 경우 즉시 추가나 삭제를 한다.

### 인덱스 키 삭제

상당히 간단

삭제 마킹된 인덱스 키 공간을 방치되거나 재활용

하지만 삭제 또한 디스크 I/O가 발생한다.

5.5 이상 버전에서 이 또한 InnoDB 스토리지 엔진에서 버퍼링되어 지연처리 가능

### 인덱스 키 변경

삭제 → 추가 

InnoDB 스토리지 엔진을 사용하는 테이블은 체인지 버퍼를 통한 처리 지연 가능

### 인덱스 키 검색

INSERT, DELETE, UPDATE에 발생하는 추가 비용을 감당하는 이유 → 빠른 검색을 위해

**인덱스를 활용한 검색 ⭕**

- 100% 일치하거나 값의 앞 부분만 일치하는 경우
- 비교 조건에서도 가능

**인덱스를 활용한 검색 ❌**

- 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도
- 인덱스 키 값에 변형이 가해진 후 비교되는 경우

      → 이미 변형된 값은 인덱스 존재하는 값이 아니다.

**InnoDB 스토리지 엔진에서의 인덱스**

- 레코드 잠금이나 넥스트 키락이 검색을 수행한 **인덱스를 잠근 후 테이블의 레코드를 잠그는 방식**
- 따라서 Update나 delete 문자이 실행될 때 테이블에 적절히 사용할 수 없는 인덱스가 없으면 불필요하게 많은 레코드를 잠그게 된다.

## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

인덱스를 구성하는 칼럼의 크기

레코드의 건수

유니크한 인덱스 키 값의 개수 등

### 인덱스 키 값의 크기

페이지 또는 블럭

= 디스크에 **데이터를 저장하는 가장 기본 단위**

= **디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위**

= InnoDB 스토리지 엔진의 **버퍼 풀에서 데이터를 버퍼링하는 기본 단위**

= 인덱스도 페이지 단위로 괸리된다.

<aside>
📌 몇 개의 자식 노드를 가져야 할까?
→ 인덱스의 페이지 크기와 키 값의 크기에 따라 결정

</aside>

페이지 크기의 기본값 16KB

 - 인덱스 키가 16바이트라 가정 

- 자식노드주소 6~12바이트, 여기서는 12라 가정

한 페이지에 저장되는 키의 수 =16*1024 / (16+12) = 585개

인덱스의 키 값 ⬆️  페이지에 저장할 수 있는 키의 개수 ⬇️ 

**한 페이지 내에서 레코드의 검색이 끝난다면 디스크 I/O 1회**

그러나 다른 페이지로 넘어가면 디스크 I/O가 증가한다.

따라서 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고 

그만큼 느려진다는 것을 의미한다.

인덱스의 키 값의 길이가 길어진다

= 전체적인 인덱스의 크기가 커진다.

→ 인덱스를 캐시해두는 InnoDB 버퍼풀은 크기가 제한적이므로 레코드의 크기가 커지면 커질수록

메모리에 캐시둘 수 있는 레코드의 수가 줄어든다.

### B-Tree 깊이

B-Tree가 깊어지는 거와 디스크 읽기가 더 많이 필요해지는 상황과 어떤 연관이 있을까?

인덱스의 키 값이 커지면 하나의 인덱스 페이지에 담을 수 있는 레코드의 개수가 줄어 들어

B-Tree의 깊이가 깊어져 디스크 읽기가 더 많이 발생한다.

### 선택도(기수성) : 유니크한 값의 수

인덱스 키 값 가운데 중복된 값⬆️ 기수성과 선택도 ⬇️

인덱스는 선택도 ⬆️ 검색 대상 ⬇️ 그만큼 빠르게 처리

총 1만 건

케이스A : country 칼럼의 유니크한 값의 개수 10개

케이스B : country 칼럼의 유니크한 값의 개수 1,000개

```sql
select *
from tb_test
where country = 'Korea' and city ='Seoul';
```

- 케이스 A
’Korea’를 찾을 때 10000/10 → 1000개의 레코드를 읽고 1000개의 레코드 잠금이 발생 
이 중 999개가 쓸데없는 읽기
- 케이스 B
’Korea’를 찾을 때 10000/1000 → 10개의 레코드를 읽고 10개의 레코드 잠금이 발생
이 중 9개가 쓸데없는 읽기

### 읽어야 하는 레코드의 건수

비용 비교

인덱스를 통해 테이블의 레코드 1건을 읽는 것 = 4~5

> 

인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것 = 1

100만 건 중 50만 건 읽기 둘 중에 무엇인 효율적일까?

- **테이블 전체를 모두 읽고 이 중에서 50만 건을 버리는 것 ⭕**
- 인덱스를 통해서 50만 건만 읽어오는 것 ❌

<aside>
📌 **인덱스를 통해서 전체 테이블의 레코드를 20~25%를 넘어서면** 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적이다.

</aside>

## 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

### 인덱스 레인지 스캔

<aside>
📌 **검색해야 할 인덱스의 범위가 결정**되었을 때 사용하는 방식

</aside>

인덱스 풀 스캔과 인덱스 루스 스캔보다 빠르다.

시작해야 할 레코드만 찾으면 그 때부터 **리프 노드의 레코드만 쭉** 읽으면 된다.

중요한 것

- **인덱스가 정렬되어 있기 때문에 어떤 방향(오름, 내림)으로 스캔해도 정렬된 상태의 레코드를 가져온다**는 것이다
- 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다.
    - **리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데 레코드 한 건 한 건 단위로 랜덤 I/O가 한 번씩 일어난다.**(세컨더리 인덱스)

인덱스 레인지 스캔 단계(세컨더리 인덱스)

```sql
1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. 이 과정을 인덱스 탐색이라고 한다.
2. 1번에서 탐색된 위치부터 필요한 만틈 인덱스를 차례대로 쭉 읽는다.
   이 과정을 인덱스 스캔이라고 한다.
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고,
   최종 레코드를 읽어온다.
```

3번 과정은 쿼리에 따라 필요로 하지 않을 수도 있다. 

조회하고자 하는 쿼리가 인덱스 칼럼에 모두 존재하는 경우 디스크 I/O가 발생하지 않을 수도 있으며

이를 `커버링 인덱스`라고 한다.

- 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 상당히 줄어든다 → 성능이 빨라진다.

### 인덱스 풀 스캔

<aside>
📌 인덱스를 처음부터 끝까지 모두 읽는 방식
**쿼리 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우
INDEX(A,B,C) → WHERE B OR C**

</aside>

![image](https://github.com/user-attachments/assets/33c7853f-11dc-4243-acb6-7dbaf06b94f8)


- 인덱스의 크키는 테이블의 크기보다 작다. (**세컨더리 인덱스의 경우?)**
- 그래서 처음부터 끝까지 읽는 것이 효율적
- 쿼리가 **인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우** 이 방식이 사용
- 레인지 스캔보다는 느리지만 테이블 풀 스캔보다는 빠르다.
- 도대체 어떤 부분에서? 커버링 인덱스를 말하는걸까?

> 인덱스를 사용한다 = 레이진 스캔이나 루스 인덱스 스캔을 말한다.
> 

### 루스 인덱스 스캔

<aside>
📌 느슨게하 **듬성듬성** 인덱스를 읽는 
레인지 스캔과 비슷하게 작동하지만 중간에 필요하지 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한다. 일반적으로 **Group by 또는 집합 함수 가운데 MIN(), MAX()**함수에 최적화를 하는 경우이다

</aside>


![image](https://github.com/user-attachments/assets/dcd4b499-8f63-41ca-92be-d5272d1a59c9)


```sql
select dept_no, min(emp_no)
from dept_emp
where dept_no between 'd002' and 'd004'
group by dept_no;
```

### 인덱스 스킵 스캔

인덱스(A,B) 

→ 쿼리 조건에 B만  : 예전에는 인덱스 사용 못했지만 지금은 인덱스 스킵 스캔으로 가능

→ 쿼리 조건에 A, B

**옵티마이저는 우선 A 칼럼에서 유니크한 값을 모두 조회해서** 

**주어진 쿼리에 gender 칼럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리**

```sql
 SELECT * FROM employees WHERE birth_date>='1965-02-01';

# 옵티마이저의 조건 추가
SELECT * FROM employees WHERE gender='M' birth_date>='1965-02-01';
SELECT * FROM employees WHERE gender='F' birth_date>='1965-02-01';
```

<aside>
📌 하지만 몇 가지 단점이 있다.

- where 조건절에 조건이 없는 인덱스의 선행 칼럼의 **유니크한 값의 개수가 적**어야 하며
    - 안 그러면 칼럼 조건을 추가해서 다시 실행하는 작업이 많이 발생한다.
- 쿼리가 인덱스 존재하는 칼럼만으로 처리 가능해야 하는 커버링 인덱스여야 한다.
</aside>

## 8.3.5 다중 칼럼(Multi-column) 인덱스

<aside>
📌 2개 이상의 칼럼으로 이루어진 인덱스

인덱스의 두번째 칼럼은 첫번째 칼럼에 의존하여 정렬되어져 있다!

N칼럼은 N-1 칼럼에 의존하여 정렬되어져 있다.

따라서 다중 칼럼은 인덱스의 위치를 신중하게 결정해야 한다.

</aside>


![image](https://github.com/user-attachments/assets/645403e4-a9b4-42c3-b13e-ce43fc9aa9b3)


## 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

인덱스 키가 오름차순이라면 오름차순으로 읽을 수 있다는 것은 아님, 거꾸로 읽으면 내림차순이 된다.

### 인덱스의 정렬

순서 혼합의 인덱스 생성이 가능해졌다.

### 인덱스의 스캔 방향

인덱스의 정렬에 따라 마음대로 읽는 방향을 바꾸면 된다

### 내림차순 인덱스

혼합된 경우에는 내림차순 인덱스로만 해결

정순 정렬 쿼리가 더 빠르다

- 페이지의 잠금이 인덱스 정순 스캔에 더 적합한 구조
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

## 8.3.7 B-Tree 인덱스의 가용성과 효율성

모른다. 

### 내림차순 인덱스 - 247page에 대한 설명

### 인덱스 풀 스캔

<aside>
📌 인덱스를 처음부터 끝까지 모두 읽는 방식
쿼리 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우

</aside>


![image](https://github.com/user-attachments/assets/5bdd87f9-0eef-4f14-b59b-b0b9500158cb)


- 인덱스의 크키는 테이블의 크기보다 작다. (**세컨더리 인덱스의 경우?)**
- 그래서 처음부터 끝까지 읽는 것이 효율적
- 쿼리가 **인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우** 이 방식이 사용
- 레인지 스캔보다는 느리지만 테이블 풀 스캔보다는 빠르다.
- 도대체 어떤 부분에서? 커버링 인덱스를 말하는걸까?

### 다른 self-balancing bst가 아닌 b-tree인 이유 (추가적으로 알아봄)

![image](https://github.com/user-attachments/assets/532acb33-8e4b-425e-88cc-715a9de11231)


https://www.youtube.com/watch?v=liPSnc6Wzfk&list=PLcXyemr8ZeoREWGhhZi5FZs6cvymjIBVe&index=28
## 인덱스 가용성과 효율성

- 작업 범위 결정 조건과 필터링 조건
- 하나의 칼럼으로 이루어진 인덱스여도 마찬가지로 왼쪽 정렬

## 멀티밸류 인덱스 ⇒ Json 

## 클러스터링 인덱스

<aside>
💡 B-Tree도 인덱스가 인덱스 키 값으로 이미 정렬되어 저장되지만 클러스터링 인덱스라고 부르지 않는 이유는 테이블의 레코드 자체가
키 값으로 정렬되어 저장되어 있지 않기 때문이다.

</aside>

- 테이블의 레코드를 비스한 것들끼리 묶어서 저장하는 형태로 구현
- InoDB 스토리지 엔진만 지원
- 테이블의 프라이머리 키에 대해서만 적용
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것
- 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야 한다

### 프라이머리 키가 없다면?

1. **Not NUll 옵셥의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키**로 선택
2. 자동으로 유니크한 값을 가지도록 **증가되는 칼럼을 내부적으로 추가한 후 클러스터링 키**로 선택
    1. 하지만 이는 사용자에게 노출되지 않으며 쿼리 문장에서 명시적으로 사용할 수 없다.

### 프라이머리 키가 세컨더리 인덱스에 미치는 영향

InnoDB의 세컨더리 인덱스의 리프노드는 물리적인 주소가 아니라 프라이머리 키를 가지고 있다.

이는 프라머리키의 주소가 변경되었을 때 세컨더리의 리프노드를 변경하는 작업이 생략되기 때문에 이런 오버헤드를 제거한다.

하지만 물리적인 주소를 가지고 있으면 바로 데이터 페이지를 통해서 레코드를 가지고 오는데 프라이머리 키를 가지고 있어

또 프라이머리 키를 가지고 검색하는 과정이 필요하다.

### 장점과 단점

장점

- 프라이머리 키로 검색할 때 처리 성능이 매우 빠르다.
- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 커버링 인덱스가 가능

단점

- 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 가지고 있어서 클러스터링 키가 큰 경우 전체적으로 인덱스의 크기가 커진다.
- 세컨더리 인덱스를 통해 검색할 때 다시 프라이머리 키로 검색하는 과정이 필요하다.
- 인서트할 때 프라이머리 키에 의해서 레코드의 저장 위치가 결졍되기 때문에 처리 성능이 느리다
- 프라이머리 키를 변경할 때 레코드를 삭제하고 다시 추가하는 작업이 필요하다.

## 유니크 인덱스

쓰기나 변경 작업 때 체인지 버터 사용 못함 성능 안좋음 → 정말 꼭 필요한 경우가 아니라면 일반적인 세컨더리 인덱스를 사용할 것

## 외래키

InnoDB 스토리지 엔진에서만 사용 가능

**외래키 제약이 설졍되면 자동으로 연관된 테이블의 칼럼에 인덱스까지 생성된다.**

### 외래키 관리에 중요한 2가지

- 테이블의 변경이 발생하는 경우에만 잠금 경합이 발생한다. - 쓰기 경합
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합을 발생시키지 않는다.

### 자식 테이블의 변경이 대기하는 경우

부모 테이블의 변경이 발생하고 자식 테이블이 부모 테이블의 외래키에 대한 변경이 발생할 때

### 부모 테이블의 변경 작업이 대기하는 경우

- 자식 테이블 수정
- 이에 대한 삭제하는 부모 쿼리

⇒ 외래키 물리적으로 생성하려면 이러한 현상으로 인한 잠금 경합까지 고려해 모델링 진
