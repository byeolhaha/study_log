## 타임아웃
- 외부 연동에서 가장 중요한 설정 중 하나는 타임 아웃이다. 
- 연동 서비스를 호출할 때 타임아웃을 적절히 설정하지 않으면, 연동 서비스에 장애가 발생했을 때 전체 서비스의 품질이 급격히 나빠질 수 있다.
- 상황
  - A 서비스의 톰캣 스레드가 200개이다 즉 동시에 200개의 요청을 처리할 수 있다.
  - 그런데 어떤 한 기능에서 외부 서비스를 이용하는데 외부 서비스에 문제가 생겨서 응답 시간이 60초를 넘기기 시작했다.
  - 이 기능에 100개의 요청이 한번에 들어왔다.
  - 그리고 10초 뒤에 다시 100개의 요청이 들어왔다.
  - 그리고 다시 10초 뒤에 100개의 요청이 들어왔지만 이전에 들어온 요청들이 외부 서비스의 응답을 대기하고 있어서 스레드를 반환하지 않았고 이로 인해서 100개의 요청은 요청을 받지 못한 채 서비스가 마비되었다.
- 위 상황에서 세번째로 온 100개의 요청이 다른 기능이었다면 한 기능의 장애가 다른 기능에도 악영향을 주고 있는 것이다.
- 그리고 유저는 응답이 오지 않으면 새로 고침을 하게 되고 이로 인해 서버의 부하는 배가 된다.
- 이러한 문제를 완화할 수 있는 방법 중 하나가 타임 아웃을 지정하는 것이다.
- 타임 아웃을 지정하면 사용자는 화가 날 수 있지만 반응 없는 무한대기보다 나으며 자원이 포화되기 전에 응답을 할 수 있다. 따라서 스레드가 부족해져서 영향을 받을 수 있는 다른 기능에도 영향을 줄일 수 있다.

### 두 가지 타임아웃 : 연결 타임아웃, 읽기 타임아웃
<img width="2244" height="1532" alt="image" src="https://github.com/user-attachments/assets/f157ebb6-49ac-4ffb-ba45-70403d643333" />

- 연결 타임 아웃
  - 일단 빛보다 느림 그래서 네트워크 상황이나 연결할 서버의 상태에 따라 오래 걸릴 수 있다.
  - 이에 함께 대기 시간도 증가하므로 연결 타임 아웃을 설정해 연결 대기 시간을 제한해야 한다.
- 읽기 타임 아웃
  - 응답을 받기 까지의 대기 시간
  - 마찬가지로 응답 대기 시간이 길면 대기 시간이 길어진다.
- 처음 연동하는 서비스라면 타임 아웃 시간을 아래와 같이 설정한 뒤에 추이를 지켜보면서 조정한다.
  - 연결 타임 아웃 : 3초 ~ 5초
  - 읽기 타임 아웃 : 5초 ~ 30초
  - 내가 외부 서비스를 연동할 때 자주 사용하는 Spring Cloud의 OpenFeign의 기본값도 함께 살펴보자.
    아래와 같다. 이 설정은 기획팀과도 이야기가 되어져야 하며 읽기 타임 아웃 60초는 너무 길어서 좀 더 줄이고 비즈니스 팀과 적절한 값을 설정하고 모니터링을 하면서 조정하는 것이 좋을 거 같다.
    | 설정 항목            | 설명                                       | 기본값        |
    | ---------------- | ---------------------------------------- | --------------- |
    | `connectTimeout` | 서버와의 **TCP 연결을 맺는 데 걸리는 최대 시간**          | `10초 (10000ms)` |
    | `readTimeout`    | 연결 후 **서버 응답을 기다리는 시간** (즉, 응답 읽기 제한 시간) | `60초 (60000ms)` |
    
- 읽기 타임 아웃을 처음부터 1~3초로 너무 짧게 설정하면 성공임에도 불구하고 에러가 자주 발생한다.
  <img width="2524" height="1548" alt="image" src="https://github.com/user-attachments/assets/004ab695-3282-4259-a573-9b4000515f2f" />
  - 위 상황에서 고객은 카드로는 결제했지만 상품은 구매하지 못하는 상황이 만들어진다. 그래서 결제처럼 민감한 기능은 읽기 타임아웃 시간을 약간 길게 설정해서 간헐적으로 연동 시간이 길어지더라도 정상적으로 처리할 수 있어야 한다.
- 추가적으로, 이 읽기 타임 아웃을 지정할 때는 실제로 설정하는 값이 무엇인지 자세히 찾아보자. 왜냐하면
  Apache HttpClient에서는 이 읽기 타임 아웃이 소켓 타임 아웃으로 이용된다. 소켓 타임 아웃은 전체 응답 시간을 의미하는 것이 아니라 네트워크 패킷 단위 기준의 응답 시간이다.
  또한 OkHttp는 읽기 타임아웃과는 별개로 호출 타임 아웃을 설정할 수 있는데 이는 요청 시작부터 응답까지의 전체 시간 기준으로 설정된다.

    
## 재시도
- 외부 연동에 실패했을 때 처리 방법 중 하나는 재시도를 하는 것이다.
### 재시도 가능 조건
- 상황
  - 포인트 서비스가 제공하는 API를 호출해 포인트를 차감하는 상황
  - 포인트 서비스를 호출하는 과정에서 읽기 타임아웃이 발생했을 때 재시도를 하면 포인트 차감이 두 번 발생한다.
  - 따라서 재시도를 해도 문제가 없는 경우에만 재시도를 해야 한다.
- 재시도를 해도 되는 조건 3가지
  - 단순 조회 기능
    - 예를 들어 포인트 내역 조회와 같은 기능
  - 연결 타임 아웃
    - 연동 서비스에 아직 연결되지 않은 상태라는 뜻
    - 읽기 타임아웃 재시도는 연동 서비스가 요청을 처리하고 있는 중이기 때문에 재시도를 하면 중복 차감되는 등의 문제가 발생할 수 있다.
  - 멱등성을 가진 변경 기능
- 같은 API라도 실패 원인에 따라 재시도 여부를 결정해야 한다.
  - 검증 오류가 발생했다면 제시도를 해도 동일하게 실패
  - 이미 좋아요 했다면 아무 작동하지 않고 200OK
### 재시도 횟수와 간격
위 3가지 조건에 따라 재시도를 도입할 수 있는 기능이라면 재시도 횟수와 간격에 대해서 고민해야 한다.
- 재시도 횟수
  - 무한정 재시도할 수 없다. 재시도 횟수만큼 응답시간도 함께 증가하기 때문에
  - 대부분의 경우 1~2번 정도의 재시도가 적당하가.
- 재시도 간격
  - 예를 들어 네트워크 연결 상태가 6초간 좋지 않은 상황이라고 가정
  - 연동 API를 호출했을 때 연결 타임아웃 시간이 3초라면 3초 뒤에 연결 타임아웃 발생,
    - 바로 재시도를 한다면 이 시도도 연결 타임아웃 발생
    - 하지만 3초 뒤에 재시도하면 성공
    - 혹은 재시도 간격을 점진적으로 늘리기
### 재시도 폭풍 안티패턴
- 재시도를 통해 성공 가능성을 높일 수 있지만, 반대로 연동 서비스에는 더 큰 부하를 줄 수 있다.
- 성능이 느려진 상태에서 새로운 요청까지 더해지면 연동 서비스의 성능은 더 나빠진다. 따라서 재시도를 검토할 때는 연동 서비스의 성능 상황도 함께 고려해야 한다.

## 동시 요청 제한
- 연동 서비스가 한 번에 처리할 수 있는 동시 요청 수가 100개라고 하자
- 이 때 연동 서비스로 동시에 300개의 요청이 들어온다면 연동 서비스는 최대 처리량을 초과해서 응답 시간이 느려지기 시작한다.
- 그러면 우리 서비스도 함께 느려진다.
- 따라서 이렇게 연동 서비스에 임계치 이상의 요청을 보내면서 발생하는 성능 저하 문제를 완화하는 방법은 연동 서비스에 요청을 일정 수준 이상으로 보내지 않는 것이다.
- 근데 나는 여기서 멀티 인스턴스 환경에서 어떻게 중앙에서 TPS를 관리하는 그 방법에 대해서 궁금했다. 대표적으로  Bucket4j + Redis를 이용해서 중앙에서 제어한다고 한다.
- 일정 이상의 요청이 오면 그 요청에 대해서
  - 503(service unavailable) Http 상태 코드를 사용하거나
  - 이 요청에 대해서 재시도를 하면 된다.
## 서킷 브레이커
- 누전 차단기와 비슷하게 작동
- 과전류가 흐르면 내려가 전기를 끊는 것처럼 과도한 오류가 발생하면 연동을 중지하고 바로 에어를 응답
- 서킷 브레이커 상태
  - 닫힘 : 모든 요청을 연동 서비스에 전달, 외부 연동 과정에서 오류가 발생하기 시작하면 지정한 임계치를 초과했는지 확인한다. 초과하면 열림 상태로 전환
  - 열림 : 연동 요청을 처리하지 않고 바로 에러를 리턴하거나 혹은 다른 대안의 연동 서비스를 이용할 수도 있다. 그리고 지정된 시간동안 유지되다가 지나면 반열림 상태가 된다.
  - 반 열림 : 일부 요청에 대해서 연동을 시도한다. 이 기간 동안 연동에 성공하면 다시 닫힌 상태로 복귀, 반대로 실패하면 열림 상태로 전환
- 빠른 실패
  -  서킷 브레이커를 문제 상황이 감지되면 해당 기능을 더 이상 실행하지 않고 바로 실패로 처리한다.
  -  이처럼 실패를 빠르게 감지하고, 문제가 있는 기능을 실행하지 않고 중단 시키는 방식을 빠른 실패하고 한다.
  -  빠른 실패는 장애가 발생한 기능에 부하가 더해지는 것을 방지하고, 불필요한 자원 낭비를 줄여 전체 서비스의 안정성을 유지하는 데도 도움이 된다.

## 외부 연동과 DB 연동
- 회원 가입 요청을 처리할 때 외부 서비스를 호출해 회원 정보를 전달하는 상황
- 모든 상황이 정상이라면 DB에 회원 데이터가 저장되고, 외부 서비스의 저장소에도 정보가 잘 저장될 것
- 하지만 모든 것이 항상 성공하는 것은 아니다.
- DB 저장하는 과정에서 실패하거나 외부 서비스를 연동하는 도중에 에러가 발생할 수 있다.

### 외부 연동과 트랜잭션 처리
- DB 연동과 외부 연동을 함께 실행할 때는 오류 발생 시 DB 트랜잭션을 어떻게 처리할지 알맞게 판단해야 한다.
- 다음은 흔히 발생할 수 있는 2가지 상황이다.
  1. 외부 연동은 실패해서 트랜잭션 롤백
  2. 외부 연동은 성공했지만 DB 연동에 실패해 트랜잭션 롤백
#### 외부 연동에 실패했을 때 트랜잭션을 롤백
외부 연동에 실패해서 트랜잭션을 롤백하는 것은 괜찮지만
아래와 같이 읽기 타임아웃 에러가 발생하는 경우, 이미 외부 서비스에서는 변경 작업이 발생했는데 DB가 롤백되는 경우를 어떻게 방어할 것인지 논의해보자
즉 트랜잭션을 롤백했지만 외부 서비스는 실제로 성공했을 경우이다. 

<img width="2604" height="1644" alt="image" src="https://github.com/user-attachments/assets/9b965a8d-0d2d-480f-a702-ed8f75cf2073" />

- 첫 번째 방법, 일정 주기로 두 시스템의 데이터가 일치하는지 확인하고 보정하는 방법이다.
  - 주문 서비스와 포인트 서비스가 하루에 한 번씩 전날 포인트 사용 내역을 비교해서 불일치 건이 있는 확인하는 식
  - 불일치가 발생하면 수동 또는 자동으로 보정한다.
- 두 번째 방법, 성공 확인 API를 호출하는 방식이다. -> 연동 서비스가 지원할 경우 가능, 그리고 이 API 자체에서도 읽기 타임 아웃이 발생할 수 있다.
  - 읽기 타임 아웃이 발생하는 경우 일정 시간 후에 이전 호출이 실제로 성공했는지 확인하는 API를 호출한다. 이때 성공 응답이 오면 트랜잭션을 지속하고, 실패 응답이 오면 트랜잭션을 롤백한다.
  - 이 방식의 변형으로 취소 API를 호출하는 방법도 있다. 읽기 타임 아웃이 발생한 뒤 일정 시간 후에 취소 API를 호출하여 연동 서비스가 취소할 대상인지 확인하는 것이다.
  - 취소할 대상이 있으면 취소 처리 수행, 없으면 아무 동작 없이 성공 응답 반환
- 따라서 두 시스템 간 데이터 일관성이 중요한 기능이라면 정기적으로 데이터 일치를 확인하는 프로세스를 갖춰야 한다.

#### 외부 연동은 성공했는데 DB 연동에 실패하는 경우 트랜잭션을 롤백
<img width="2204" height="1812" alt="image" src="https://github.com/user-attachments/assets/64ee906f-8576-4a8f-bf2f-97994d8f79db" />
- 외부 연동은 성공했지만 DB 연동에 실패해 트랜잭션이 롤백되는 경우에는 취소 API를 호출해 외부 연동을 이전 상태로 되돌리는 것이 필요하다.
- DB 연동에 실패했기 때문에 이 경우 성공 API를 호출해도 의미가 없다, 단 이도 취소 API를 외부 서비스에서 제공해야 하기 때문에 데이터 일관성이 중요한 서비스라면 일정 주기로 데이터가 맞는지 비교하는 프로세스를 갖추는 것이 좋다.


