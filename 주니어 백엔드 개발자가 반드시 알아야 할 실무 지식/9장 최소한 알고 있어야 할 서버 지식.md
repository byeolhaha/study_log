## OS 계정과 권한
- root 계정 : OS를 설피하면 기본 생성되는 계정으로 모든 권한을 가진 계정
- 파일이나 디렉토리에 대한 권한 명령어 ls -l
  ![image](https://github.com/user-attachments/assets/d0be0df4-1140-4220-8a1d-5bfb280cdf9a)
  파일 권한 부분
  - 첫 세글자 : 소유자의 권한
  - 중간 세글자 : 그룹의 권한
  - 마지막 세글자 : 다른 사용자의 권한
  - rwx
    - r(읽기) : 4
    - w(쓰기) : 2
    - x(실행) : 1
    ```
    chmod 754 run.sh
    chmod u+x run.sh//사용자에게 실행 권한을
    ```
  - chmod 관련
    누구에게
    - u(소유자)
    - g (그룹)
    - o(다른 사용자)
    - a(모두)
    어떻게
    - +(추가)
    - -(제거)
    - =(지정)
    무엇을
    - r(읽기)
    - w(쓰기) 
    - x(실행)
### sudo로 권한주기
- root 권한은 일부 인프라 담당자만, 개발자는 일반 계정에 대한 권한만
- 그러나 개발자도 root 권한이 필요할 때가 있는데 이 때마다 매번 인프라 담당자에게 요청하면 업무 효율이 떨어진다. 이 때 사용하는 명령어가 sudo이다.
- sudo 명령어를 사용하면 다른 사용자의 권한으로 프로그램을 실행할 수 있다.
- sudo 명령어로 실행할 수 있는 명령어를 별도로 관리하는 설정 파일
  - /etc/sudoers
  - /etc/sudoers.d
- /etc/sudoers 살펴보기 (해당 파일은 읽기 전용이기 때문에 해당 파일을 vi 명령어로 수정하려면 수정 전/후로 권한을 변경해야 하기 때문에 visudo를 사용하자)
  ```
  root    ALL=(ALL)       ALL
  │       │      │         └ 실행할 수 있는 명령 (모든 명령)
  │       │      └ 대상 사용자로 전환 가능 (모든 사용자로 전환 가능)
  │       └ 명령을 실행할 수 있는 호스트 (모든 호스트)
  └ sudo 권한을 부여받는 사용자 (여기서는 root)

  ```
  root 사용자는 모든 호스트에서, 모든 사용자로 전환하여, 모든 명령어를 실행할 수 있다.
  ```
  user1 ALL(=ALL) ALL
  ```
  user1 계정에 ***sudo로 모든 명령어를 실행할 수 있는 권한을 부여***한다.
  ```
  [user1@myserer ~]$ sudo su
  [sudo] user1의 암호 : 
  ```
  하지만 sudo 명령어를 이용해서 실행할 때는 user1은 암호를 입력해야 하기 때문에 해당 부분이 번거롭다면 암호 입력 없이 실행할 수 있다.
  그러고자 한다면 아래와 같이 설정을 수정하자. -> 하지만 이는 위험하다 root 실행 권한을 부여한 것이나 다름이 없기 때문이다. 테스트할 때나 사용하자
  ```
  user1 ALL(=ALL) NOPASSWD: ALL
  ```
  따라서 아래와 같이 특정 명령어와 암호화 없는 조합을 사용하는 것이 일반적이다.
  ```
  user1 ALL(=ALL) NOPASSWD: /usr/bin/systemctl
  ```
  ## 프로세스 확인하기
  - 프로세스 ID 목록 확인하는 것은 보통의 경우 해당 프로세스를 종료시키기 위할 때이다. 아래와 같은 명령어로를 사용한다.
    ```
    ps aux
    ps -eaf
    ```
    <img width="690" height="100" alt="image" src="https://github.com/user-attachments/assets/0f4852e8-d678-4174-b80e-a16fa8cd7385" />
  - 프로세스가 사용하는 CPU나 메모리 사용량 실시간으로 확인할 때
    생각보다 이 명령어들은 요긴하게 사용할 때가 많다. 회사에서 서버가 멈추는 경우가 가끔씩 있는데 그 경우가 대부분은 메모리가 가득 찼었고 그로 인해 서버가 다운된 적이 있었다.
    리눅스의 경우 아래와 같이 작동하니 메모리는 잘 관리하는 것이 좋다.
    1. 메모리가 부족해지면?
    리눅스 커널은 다음과 같은 순서로 대응한다.
     - page cache를 비우고 스왑(Swap)을 사용
     - 그래도 부족하면 → OOM Killer(Out of Memory Killer) 작동
    2. OOM Killer란?
     - 커널이 메모리 부족 상황에서 강제로 프로세스를 종료시키는 메커니즘
     - 프로세스의 메모리 사용량, 중요도 등을 기준으로 가장 "덜 중요하고 많이 차지하는" 프로세스를 종료
     - 결정은 /proc/[pid]/oom_score 값 기반으로 함 (점수가 높을수록 죽기 쉬움)
    ```
    top
    ```
    <img width="822" height="620" alt="image" src="https://github.com/user-attachments/assets/47c80e6b-bb1d-4a37-99d0-46782f2fc58c" />


    htop은 top보다 더 개선된 명령어다 아래를 보면 클릭을 통해서 정렬이 가능하다.
    ```
    htop
    ```
    <img width="1543" height="596" alt="image" src="https://github.com/user-attachments/assets/c31fb24c-ad5f-4493-9060-b0e1bcc328b6" />
    <img width="1312" height="576" alt="image" src="https://github.com/user-attachments/assets/4f3dceec-6bb0-49f1-811a-9f412eb420d1" />

    ps 명령어로도 확인이 가능하다.
    cpu에 사용률에 대한 10위까지
    ```
    ps aux --sort=-%cpu | head -n 10
    ```
    memory 사용률에 대한 10위까지
    ```
    ps aux --sort=-%mem | head -n 10
    ```
### 프로세스 종료
```
kill 옵션 프로세스ID
```

