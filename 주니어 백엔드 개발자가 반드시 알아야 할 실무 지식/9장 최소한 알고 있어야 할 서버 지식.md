## OS 계정과 권한
- root 계정 : OS를 설피하면 기본 생성되는 계정으로 모든 권한을 가진 계정
- 파일이나 디렉토리에 대한 권한 명령어 ls -l
  ![image](https://github.com/user-attachments/assets/d0be0df4-1140-4220-8a1d-5bfb280cdf9a)
  파일 권한 부분
  - 첫 세글자 : 소유자의 권한
  - 중간 세글자 : 그룹의 권한
  - 마지막 세글자 : 다른 사용자의 권한
  - rwx
    - r(읽기) : 4
    - w(쓰기) : 2
    - x(실행) : 1
    ```
    chmod 754 run.sh
    chmod u+x run.sh//사용자에게 실행 권한을
    ```
  - chmod 관련
    누구에게
    - u(소유자)
    - g (그룹)
    - o(다른 사용자)
    - a(모두)
    어떻게
    - +(추가)
    - -(제거)
    - =(지정)
    무엇을
    - r(읽기)
    - w(쓰기) 
    - x(실행)
### sudo로 권한주기
- root 권한은 일부 인프라 담당자만, 개발자는 일반 계정에 대한 권한만
- 그러나 개발자도 root 권한이 필요할 때가 있는데 이 때마다 매번 인프라 담당자에게 요청하면 업무 효율이 떨어진다. 이 때 사용하는 명령어가 sudo이다.
- sudo 명령어를 사용하면 다른 사용자의 권한으로 프로그램을 실행할 수 있다.
- sudo 명령어로 실행할 수 있는 명령어를 별도로 관리하는 설정 파일
  - /etc/sudoers
  - /etc/sudoers.d
- /etc/sudoers 살펴보기 (해당 파일은 읽기 전용이기 때문에 해당 파일을 vi 명령어로 수정하려면 수정 전/후로 권한을 변경해야 하기 때문에 visudo를 사용하자)
  ```
  root    ALL=(ALL)       ALL
  │       │      │         └ 실행할 수 있는 명령 (모든 명령)
  │       │      └ 대상 사용자로 전환 가능 (모든 사용자로 전환 가능)
  │       └ 명령을 실행할 수 있는 호스트 (모든 호스트)
  └ sudo 권한을 부여받는 사용자 (여기서는 root)

  ```
  root 사용자는 모든 호스트에서, 모든 사용자로 전환하여, 모든 명령어를 실행할 수 있다.
  ```
  user1 ALL(=ALL) ALL
  ```
  user1 계정에 ***sudo로 모든 명령어를 실행할 수 있는 권한을 부여***한다.
  ```
  [user1@myserer ~]$ sudo su
  [sudo] user1의 암호 : 
  ```
  하지만 sudo 명령어를 이용해서 실행할 때는 user1은 암호를 입력해야 하기 때문에 해당 부분이 번거롭다면 암호 입력 없이 실행할 수 있다.
  그러고자 한다면 아래와 같이 설정을 수정하자. -> 하지만 이는 위험하다 root 실행 권한을 부여한 것이나 다름이 없기 때문이다. 테스트할 때나 사용하자
  ```
  user1 ALL(=ALL) NOPASSWD: ALL
  ```
  따라서 아래와 같이 특정 명령어와 암호화 없는 조합을 사용하는 것이 일반적이다.
  ```
  user1 ALL(=ALL) NOPASSWD: /usr/bin/systemctl
  ```
  ## 프로세스 확인하기
  - 프로세스 ID 목록 확인하는 것은 보통의 경우 해당 프로세스를 종료시키기 위할 때이다. 아래와 같은 명령어로를 사용한다.
    ```
    ps aux
    ps -eaf
    ```
    <img width="690" height="100" alt="image" src="https://github.com/user-attachments/assets/0f4852e8-d678-4174-b80e-a16fa8cd7385" />
  - 프로세스가 사용하는 CPU나 메모리 사용량 실시간으로 확인할 때
    생각보다 이 명령어들은 요긴하게 사용할 때가 많다. 회사에서 서버가 멈추는 경우가 가끔씩 있는데 그 경우가 대부분은 메모리가 가득 찼었고 그로 인해 서버가 다운된 적이 있었다.
    리눅스의 경우 아래와 같이 작동하니 메모리는 잘 관리하는 것이 좋다.
    1. 메모리가 부족해지면?
    리눅스 커널은 다음과 같은 순서로 대응한다.
     - page cache를 비우고 스왑(Swap)을 사용
     - 그래도 부족하면 → OOM Killer(Out of Memory Killer) 작동
    2. OOM Killer란?
     - 커널이 메모리 부족 상황에서 강제로 프로세스를 종료시키는 메커니즘
     - 프로세스의 메모리 사용량, 중요도 등을 기준으로 가장 "덜 중요하고 많이 차지하는" 프로세스를 종료
     - 결정은 /proc/[pid]/oom_score 값 기반으로 함 (점수가 높을수록 죽기 쉬움)
    ```
    top
    ```
    <img width="822" height="620" alt="image" src="https://github.com/user-attachments/assets/47c80e6b-bb1d-4a37-99d0-46782f2fc58c" />


    htop은 top보다 더 개선된 명령어다 아래를 보면 클릭을 통해서 정렬이 가능하다.
    ```
    htop
    ```
    <img width="1543" height="596" alt="image" src="https://github.com/user-attachments/assets/c31fb24c-ad5f-4493-9060-b0e1bcc328b6" />
    <img width="1312" height="576" alt="image" src="https://github.com/user-attachments/assets/4f3dceec-6bb0-49f1-811a-9f412eb420d1" />

    ps 명령어로도 확인이 가능하다.
    cpu에 사용률에 대한 10위까지
    ```
    ps aux --sort=-%cpu | head -n 10
    ```
    memory 사용률에 대한 10위까지
    ```
    ps aux --sort=-%mem | head -n 10
    ```
    
### 프로세스 종료
```
kill 옵션 프로세스ID
```
옵션 보통 2가지
- -15 또는 -s SIGTERM 또는 -TERM : 기본값, 프로세스에 TERM 신호를 보낸다. 이 신호를 받은 프로세스는 종료에 필요한 작업을 수행한다. 예를 들어 임시로 생성한 파일을 삭제하거나, 스프링 빈의 제거 처리를 하는 작업을 수행한다.
- -9 또는 -s SIGKILL 또는 -KILL : 프로세스를 강제 종료한다. 프로그램이 종료할 때 수행하는 정리작업이 없기 때문에 주의해서 사용할 것
  실제로 배포 스크립트를 보면 아래와 같이 kill -9을 하는 경우가 있다. 하지만 이렇게 하는 것보다는 -15 옵션으로 여러 차례 종료를 시도하고 그럼에도 안되었을 때 -9을 시도하자.
  ```
  ps -ef | grep java | grep $run_id | awk '{print $2}'
  ```

## 백그라운드 프로세스
- 포그라운드 프로세스
  ```
  tail -f out.log
  ```
  - 이 명령어는 tail 명령어가 실행되는 동안 out.log 파일에 추가된 내용을 출력한다. 해당 명령어를 종료하려면 ctrl+c를 누른다.
  - tail, top, vi 처럼 서버에 접속한 뒤 터미널에 실행되는 프로그램은 기본적으로 포그라운드 프로세스이다.
  - 이는 키보드나 스크린을 통해서 상호작용을 진행한다.
  - 터미널과 연결되어 있어서 사용자의 터미널 연결이 끊기면 종료된다.
- 백그라운드 프로세스
  - 톰캣과 같은 서버 프로세스는 항상 실행되어 있어야 한다. 따라서 백그라운드 프로세스로 동작해야 한다.
  - 터미널과 연결되지 않은 프로세스를 말하며 터미널과 연결되어 있지 않으므로 키보드나 스크린을 통해 사용자와의 상호작용을 할 수 없다.
  ```
  $ java -Dserver.port=9000 -jar server.jar &
  ```
  - 명령어 뒤에 &을 붙이면 프로세스가 백그라운드로 실행된다. 다른 포그라운드와 동시에 실행 가능
  - 하지만 사용자가 터미널을 종료하면 함께 종료될 수 있다.
  - 이는 터미널과 연결된 세션 내에서 백그라운드로 실행되는 것
  - 터미널을 종료하거나 로그아웃하면 SIGHUP (Hangup) 시그널이 해당 세션의 모든 자식 프로세스(백그라운드 포함)에게 전달된다.
  - 대부분의 프로그램은 기본적으로 SIGHUP을 받으면 종료되도록 되어 있다.그래서 단순히 &만 붙인 프로세스는 터미널 종료 시 같이 죽는다.
  ```
  $ nohup -Dserver.port=9000 -jar server.jar &
  ```
  - 그래서 터미널을 종료해도 백그라운도 프로세스가 계속 실행되려면 nohup과 함께 이용한다.
  - nohup 명령어로 실행한 프로세스가 콘솔에 출력하는 내용은 기본적으로 nohup.out파일에 기록된다.
  ```
  $ nohup -Dserver.port=9000 -jar server.jar > server.log 2>&1 &
  ```
  - nohup.out 파일이 아닌 다른 파일에 저장하고 싶다면 리다이렉션을 이용한다.
  - 위 명령어는 프로세스가 콘솔에 출력하는 메시지를 server.log에 출력한다.
  - ```2``` : 표준 오류
  - ```>``` : 리다이렉션
  - ```&1``` : 표준 출력
  - 표준 오류를 표준 출력과 동일한 경로로 전달하라는 의미 

## 디스크 용량 관리 
